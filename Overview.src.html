<!doctype html>
<meta charset=UTF-8>
<title>Web DOM Core</title>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<style>
 pre, code { font-family:monospace, sans-serif; }
 h2 code, h3 code, h4 code,
 h2 :link, h3 :link, h4 :link,
 h2 :visited, h3 :visited, h4 :visited
 { font:inherit; color:inherit; font-style:italic; }
 @media print {
   [data-anolis-spec]::after {
     content: "[" attr(data-anolis-spec) "]";
     font-size: 0.6em;
     vertical-align: super;
     text-transform: uppercase;
   }
 }
</style>
<body class=draft>
<div class=head id=head>
<h1>Web DOM Core</h1>
<h2 class="no-num no-toc">Work in Progress &mdash; Last Update [DATE: 01 Jan 1901]</h2>
<dl>
 <dt>Editors
 <dd>Simon Pieters &lt;simonp@opera.com>
 <dd>Geoffrey Sneddon &lt;gsneddon@opera.com>
 <dd>Ms2ger &lt;ms2ger@gmail.com>
 <dd>Anne van Kesteren &lt;annevk@opera.com>

 <dt>PDF print version
 <dd><a href=web-dom-core.pdf>Letter</a>

 <dt>Version history
 <dd><a href=http://bitbucket.org/ms2ger/web-dom-core/>http://bitbucket.org/ms2ger/web-dom-core</a>
 <dd><a href=http://hg.gsnedders.com/web-dom-core>http://hg.gsnedders.com/web-dom-core</a>
 <dd><a href=http://simon.html5.org/specs/web-dom-core>http://simon.html5.org/specs/web-dom-core</a>
</dl>
</div>



<h2 class="no-num no-toc">Issues</h2>

<ul class=XXX>
 <li>This specification like DOM3Core currently talks about name. Specifications mostly use qualifiedName for DOM1Core methods. We should too.
 <li>Should define how XML maps to the DOM. Infoset?! And prolly how the DOM maps to XML. Maybe by using HTML5 XHTML5 section.
 <li>innerHTML etc on all Elements
  <a href=http://lists.w3.org/Archives/Public/public-html/2007Aug/0778.html>public-html/2007Aug/0778.html</a>
  <a href=http://lists.w3.org/Archives/Public/public-webapi/2007Aug/0070.html>public-webapi/2007Aug/0070.html</a>
 <li>\0 <a href=http://krijnhoetmer.nl/irc-logs/whatwg/20080321#l-312>http://krijnhoetmer.nl/irc-logs/whatwg/20080321#l-312</a>
 <li>[Reflect] <a href=http://krijnhoetmer.nl/irc-logs/whatwg/20090622#l-90>http://krijnhoetmer.nl/irc-logs/whatwg/20090622#l-90</a>
 <li>Perhaps we should move DOMStringMap to this spec...
</ul>



<h2 class="no-num no-toc">Abstract</h2>
<p>This specification defines the DOM Core part of the Web platform. The Document Object Model is a language- and platform neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents. Web DOM Core mostly subsets DOM3 Core, but redefines some things and adds some features that were widely implemented already.



<h2 class="no-num no-toc">Table of contents</h2>
<!--toc-->



<h2 class="no-num no-toc">List of tables</h2>
<div id=anolis-listoftables></div>


<h2>Goals</h2>

<ul>
 <li>Align DOM Core with needs of ECMAScript first, everything else third. (Of course due to Web IDL it'll work, but compatibility with DOM Level 3 Core is not guaranteed.)</li>
 <li>Align DOM Core with existing implementations.</li>
 <li>Simplify DOM Core as much as possible.</li>
 <li>Import bits of HTML5 that ought to be in DOM Core.</li>
 <li>Prevent a dependency on HTML5.</li>
</ul>

<p>Obsoleting DOM Level 3 Core is not an explicit goal. It is a fine specification for Java servers.</p>

<p>New features might be added, once everything else is sort of stable.</p>


<h2>Common infrastructure</h2>
<h3>Terminology</h3>
<p>The term <dfn>tree order</dfn> means a pre-order, depth-first traversal of DOM nodes involved (through the <code title=dom-Node-parentNode>parentNode</code>/<code title=dom-Node-childNodes>childNodes</code> relationship).

<p>The term <dfn>context node</dfn> means the <code>Node</code> on which the method or attribute being discussed was called.

<p>The term <dfn>root element</dfn>, when not explicitly qualified
as referring to the document's root element, means the furthest
ancestor element node of whatever node is being discussed, or the
node itself if it has no ancestors. When the node is a part of the
document, then the node's <span>root element</span> is indeed the
document's root element; however, if the node is not currently part
of the document tree, the root element will be an orphaned node.</p>

<p>When an element's <span>root element</span> is the root element
of a <code>Document</code>, it is said to be <dfn>in a
<code>Document</code></dfn>.

<p>A node's <dfn>home subtree</dfn> is the subtree rooted at that
node's <span>root element</span>. When a node is <span>in a
<code>Document</code></span>, its <span>home subtree</span> is that
<code>Document</code>'s tree.

<p>The <dfn title="space character">space characters</dfn>, for the
purposes of this specification, are U+0020 SPACE, U+0009 CHARACTER
TABULATION (tab), U+000A LINE FEED (LF), U+000C FORM FEED (FF), and
U+000D CARRIAGE RETURN (CR).</p>


<h3>Conformance requirements</h3>
<p>All diagrams, examples, and notes in this specification are
non-normative, as are all sections explicitly marked non-normative.
Everything else in this specification is normative.</p>

<p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
NOT",--> "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in the normative parts of this document are to be
interpreted as described in RFC2119. For readability, these words do
not appear in all uppercase letters in this specification. <span
data-anolis-ref>RFC2119</span></p>

<p>Requirements phrased in the imperative as part of algorithms
(such as "strip any leading space characters" or "return false and
abort these steps") are to be interpreted with the meaning of the
key word ("must", "should", "may", etc) used in introducing the
algorithm.</p>

<p>Conformance requirements phrased as algorithms or specific steps
may be implemented in any manner, so long as the end result is
equivalent. (In particular, the algorithms defined in this
specification are intended to be easy to follow, and not intended to
be performant.)</p>

<p id="hardwareLimitations">User agents may impose
implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running
out of memory, or to work around platform-specific limitations.</p>

<p>When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can't change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.

<p>Unless otherwise stated, string comparisons are done in a <span>case-sensitive</span> manner.

<h4>Dependencies</h4>

<p>The IDL fragments in this specification must be interpreted as
required for conforming IDL fragments, as described in the Web IDL
specification. <span data-anolis-ref>WEBIDL</span>

<p id=float-nan>Except where otherwise specified, if an IDL attribute that is a
floating point number type (<code data-anolis-spec=webidl>float</code>) is
assigned an Infinity or Not-a-Number (NaN) value, a <code
title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception must
be raised.

<p>Except where otherwise specified, if a method with an argument that is a
floating point number type (<code data-anolis-spec=webidl>float</code>) is
passed an Infinity or Not-a-Number (NaN) value, a <code
title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception
must be raised.

<p>Some of the terms used in this specification are defined in <cite>Web
IDL</cite>, <cite>XML</cite> and <cite>Namespaces in XML</cite>.
<span data-anolis-ref>WEBIDL</span>
<span data-anolis-ref>XML</span>
<span data-anolis-ref>XMLNS</span>

<h4>Extensibility</h4>

<p>Vendor-specific proprietary extensions to this specification are
strongly discouraged. Authors must not use such extensions, as
doing so reduces interoperability and fragments the user base,
allowing only users of specific user agents to access the content in
question.</p>

<p>If vendor-specific extensions are needed, the members should be
prefixed by vendor-specific strings to prevent clashes with future
versions of this specification. Extensions must be defined so that
the use of extensions neither contradicts nor causes the
non-conformance of functionality defined in the specification.</p>
<!-- thanks to QA Framework -->

<p>When vendor-neutral extensions to this specification are needed,
either this specification can be updated accordingly, or an
extension specification can be written that overrides the
requirements in this specification. When someone applying this
specification to their activities decides that they will recognise
the requirements of such an extension specification, it becomes an
<dfn title="other applicable specifications">applicable
specification</dfn> for the purposes of conformance requirements in
this specification.</p>
<!-- http://www.w3.org/mid/17E341CD-E790-422C-9F9A-69347EE01CEB@iki.fi -->


<h3>Case-sensitivity</h3>
<p>This specification defines several comparison operators for strings.
<p>Comparing two strings in a <dfn>case-sensitive</dfn> manner means comparing them exactly, codepoint for codepoint.
<p>Comparing two strings in a <dfn>ASCII case-insensitive</dfn> manner means comparing them exactly, codepoint for codepoint, except that the characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.
<p><dfn title="converted to uppercase">Converting a string to uppercase</dfn> means replacing all characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) with the corresponding characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z).
<p><dfn title="converted to lowercase">Converting a string to lowercase</dfn> means replacing all characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).


<h3>Common microsyntaxes</h3>
<h4>Common parser idioms</h4>
<p>Some of the micro-parsers described below follow the pattern of
having an <var>input</var> variable that holds the string
being parsed, and having a <var>position</var> variable
pointing at the next character to parse in <var
title="">input</var>.</p>

<p>For parsers based on this pattern, a step that requires the user
agent to <dfn>collect a sequence of characters</dfn> means that the
following algorithm must be run, with <var>characters</var>
being the set of characters that can be collected:</p>

<ol>

 <li><p>Let <var>input</var> and <var
 title="">position</var> be the same variables as those of the same
 name in the algorithm that invoked these steps.</p></li>

 <li><p>Let <var>result</var> be the empty string.</p></li>

 <li><p>While <var>position</var> doesn't point past the
 end of <var>input</var> and the character at <var
 title="">position</var> is one of the <var
 title="">characters</var>, append that character to the end of <var
 title="">result</var> and advance <var>position</var> to
 the next character in <var>input</var>.</p></li>

 <li><p>Return <var>result</var>.</p></li>

</ol>

<p>The step <dfn>skip whitespace</dfn> means that the user agent
must <span>collect a sequence of characters</span> that are <span
title="space character">space characters</span>. The collected
characters are not used.

<h4>Space-separated tokens</h4>
<p>A <dfn>set of space-separated tokens</dfn> is a string containing
zero or more words separated by one or more <span title="space
character">space characters</span>, where words consist of any
string of one or more characters, none of which are <span
title="space character">space characters</span>.</p>

<p>A string containing a <span>set of space-separated tokens</span>
may have leading or trailing <span title="space character">space
characters</span>.</p>

<div class="impl">

<p>When a user agent has to <dfn>split a string on spaces</dfn>, it
must use the following algorithm:</p>

<ol>

 <li><p>Let <var>input</var> be the string being
 parsed.</p></li>

 <li><p>Let <var>position</var> be a pointer into <var
 title="">input</var>, initially pointing at the start of the
 string.</p></li>

 <li><p>Let <var>tokens</var> be a list of tokens,
 initially empty.</p></li>

 <li><p><span>Skip whitespace</span></p></li>

 <li><p>While <var>position</var> is not past the end of
 <var>input</var>:</p>

  <ol>

   <li><p><span>Collect a sequence of characters</span> that are not
   <span title="space character">space characters</span>.</p></li>

   <li><p>Add the string collected in the previous step to <var
   title="">tokens</var>.</p></li>

   <li><p><span>Skip whitespace</span></p></li>

  </ol>

 </li>

 <li><p>Return <var>tokens</var>.</p></li>

</ol>

<p>When a user agent has to <dfn>remove a token from a string</dfn>,
it must use the following algorithm:</p>

<ol>

 <li><p>Let <var>input</var> be the string being modified.

 <li><p>Let <var>token</var> be the token being removed. It will not
 contain any <span title="space character">space characters</span>.

 <li><p>Let <var>output</var> be the output string, initially empty.

 <li><p>Let <var>position</var> be a pointer into <var>input</var>,
 initially pointing at the start of the string.

 <li><p><i title>Loop</i>: If <var>position</var> is beyond the end of
 <var>input</var>, abort these steps.

 <li>
  <p>If the character at <var>position</var> is a <span>space
  character</span>:

  <ol>
   <li><p>Append the character at <var>position</var> to the end of <var
   title>output</var>.

   <li><p>Advance <var>position</var> so it points at the next character
   in <var>input</var>.

   <li><p>Return to the step labeled <i title>loop</i>.
  </ol>

 <li><p>Otherwise, the character at <var>position</var> is the first
 character of a token. <span>Collect a sequence of characters</span> that are
 not <span title="space character">space characters</span>, and let that be <var
 title>s</var>.

 <li>
  <p>If <var>s</var> is exactly equal to <var>token</var>, then:

  <ol>
   <li><p><span>Skip whitespace</span> (in <var>input</var>).

   <li><p>Remove any <span title="space character">space characters</span>
   currently at the end of <var>output</var>.

   <li><p>If <var>position</var> is not past the end of <var
   title>input</var>, and <var>output</var> is not the empty string,
   append a single U+0020 SPACE character at the end of <var>output</var>.
  </ol>

 <li><p>Otherwise, append <var>s</var> to the end of <var
 title>output</var>.

 <li><p>Return to the step labeled <i title>loop</i>.</p></li>
</ol>

<p class="note">This causes any occurrences of the token to be
removed from the string, and any spaces that were surrounding the
token to be collapsed to a single space, except at the start and end
of the string, where such spaces are removed.</p>

</div>


<h3>DOM features</h3>
<p>A <dfn title=concept-DOMfeature>DOM feature</dfn> is a unique,
<span>ASCII case-insensitive</span> string that represents a certain feature of
the user agent.

<p>A <dfn title=concept-DOMfeatureversion>DOM feature version</dfn> is a (<var
title>feature string</var>,&nbsp;<var>version</var>) tuple, where <var
title>feature string</var> is <span title=concept-DOMfeature>DOM feature</span>
and <var>version</var> is a <span>case-sensitive</span> string
representing a version number.
<!--of the form "<var>major</var>.<var>minor</var>".-->

<p>Specifications may define which <span title=concept-DOMfeature>DOM
features</span> a user agent is to <dfn
title=concept-support-DOMfeature>support</dfn>, as well as an associated list of
one or more <span>case-sensitive</span> strings representing version numbers,
and under which circumstances.

<p>A user agent must <dfn title=concept-support-DOMfeatureversion>support</dfn>
a <span title=concept-DOMfeatureversion>DOM feature version</span> (<var
title>feature string</var>,&nbsp;<var>version</var>) if it <span
title=concept-support-DOMfeature>supports</span> a <span
title=concept-DOMfeature>DOM feature</span> that is a <span>ASCII
case-insensitive</span> match for <var>feature string</var> and <var
title>version</var> is in the associated list of versions.

<p>A user agent must <span
title=concept-support-DOMfeatureversion>support</span> the (<var
title>feature</var>,&nbsp;"") tuple if it <span
title=concept-support-DOMfeature>supports</span> a <span
title=concept-DOMfeature>DOM feature</span> that is a <span>ASCII
case-insensitive</span> match for <var>feature string</var>.

<p class=note>Authors are strongly discouraged from using <span
title=concept-DOMfeature>DOM features</span>, as they are notoriously unreliable
and imprecise. Authors are encouraged to rely on explicit feature testing or
graceful degradation.

<p>For historical reasons, user agents must <span
title=concept-support-DOMfeatureversion>support</span> the
"XML" <span title=concept-DOMfeature>DOM feature</span> with the versions "1.0"
and "2.0" associated with it, and the "Core" <span title=concept-DOMfeature>DOM
feature</span> with the version "2.0" associated with it.

<!-- Chrome supports Core/1.0; Opera supports x/undefined -->


<h3>Cloning nodes</h3>
<p>When a UA is to <dfn>clone</dfn> a <var>node</var>, with a <var>new ownerDocument</var> and with a <i>clone children flag</i>, it must run the following steps:

<ol>
 <li><p>If <var>node</var> is a <code>DocumentType</code> node, raise a <code title=dom-DOMException-DATA_CLONE_ERR>DATA_CLONE_ERR</code> exception and abort these steps.
 <li>
  <p>Let <var>copy</var> be a new <code>Node</code> that implements the same interfaces as <var>node</var>, with <code title=dom-Node-ownerDocument>ownerDocument</code> set to <var>new ownerDocument</var>, <code title="dom-Node-prefix">prefix</code>, <code title="dom-Node-localName">localName</code> and <code title="dom-Node-namespaceURI">namespaceURI</code> attributes set to the values of the attributes on <var>node</var> with the same names, and other attributes set to the values of the attributes on <var>node</var> with the same names depending on the type of <var>node</var> according to the following table:</p>
  <table>
   <caption>Cloned attributes</caption>
   <thead>
    <tr><th>Type of <var>node</var><th>Attributes
   <tbody>
    <tr><td><code>Element</code><td>&mdash;
    <tr><td><code>Attr</code><td><code title=dom-Attr-value>value</code>
    <tr><td><code>Text</code><td><code title=dom-CharacterData-data>data</code>
    <tr><td><code>ProcessingInstruction</code><td><code title=dom-ProcessingInstruction-target>target</code>, <code title=dom-ProcessingInstruction-data>data</code>
    <tr><td><code>Comment</code><td><code title=dom-CharacterData-data>data</code>
    <tr><td><code>DocumentFragment</code><td>&mdash;
  </table>
 <li>
  <p>If <var>node</var> is an <code>Element</code> node, let <var>copy</var>'s <code title=dom-Node-attributes>attributes</code> be a new <code>NamedNodeMap</code>, and for each <code>Attr</code> <var>old attribute</var> in <var>node</var>'s <code title=dom-Node-attributes>attributes</code>, <span>clone</span> it and append it to the <var>copy</var>'s <code title=dom-Node-attributes>attributes</code>.
 <li><p>If the <i>clone children flag</i> is set, <span>clone</span> all the children of <var>node</var> and append them to <var>copy</var>, with the same <var>new ownerDocument</var> and the <i>clone children flag</i> being set.
 <li><p>Return <var>copy</var>.
</ol>


<h3>Legal hierarchy</h3>
<p class=XXX>Simon says this section is buggy. Should we just remove it?

<p>A <code>Node</code> is said to have a <dfn>legal hierarchy</dfn> if all the following conditions are true:

<ul>
 <li><p>The <code>Node</code> is a <code>Document</code> node or an <code>Attr</code> node and has no parent node.
 <li><p>The <code>Node</code> is a <code>Document</code> node and has no child <code>Text</code> nodes.
 <li><p>The <code>Node</code> is a <code>Document</code> node and has no more than one child <code>Element</code> node.
 <li><p>The <code>Node</code> is an <code>Attr</code> node, a <code>Text</code> node, a <code>ProcessingInstruction</code> node, a <code>Comment</code> node, or a <code>DocumentType</code> node, and has no child nodes.
</ul>

<p>Before running the steps of an algorithm of a method or attribute in this specification, the user agent must check that running the algorithm will result in a <span>legal hierarchy</span>. If it won't, then the user agent must instead raise a <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code> exception.


<h3>Namespaces</h3>
<p>The <dfn>HTML namespace</dfn> is <code
title>http://www.w3.org/1999/xhtml</code>.

<p>The <dfn>XML namespace</dfn> is <code
title>http://www.w3.org/XML/1998/namespace</code>.

<p>The <dfn>XMLNS namespace</dfn> is <code
title>http://www.w3.org/2000/xmlns/</code>.



<h2>Basic types</h2>
<p>A <dfn>DOMTimeStamp</dfn> represents a number of milliseconds.
<pre class=idl>typedef unsigned long long DOMTimeStamp;</pre>



<h2>Exceptions</h2>
<h3>Exception <code>DOMException</code></h3>
<pre class=idl>exception <dfn>DOMException</dfn> {
  const unsigned short <span title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</span> = 1;
  const unsigned short <span title=dom-DOMException-DOMSTRING_SIZE_ERR>DOMSTRING_SIZE_ERR</span> = 2; // historical
  const unsigned short <span title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</span> = 3;
  const unsigned short <span title=dom-DOMException-WRONG_DOCUMENT_ERR>WRONG_DOCUMENT_ERR</span> = 4;
  const unsigned short <span title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</span> = 5;
  const unsigned short <span title=dom-DOMException-NO_DATA_ALLOWED_ERR>NO_DATA_ALLOWED_ERR</span> = 6; // historical
  const unsigned short <span title=dom-DOMException-NO_MODIFICATION_ALLOWED_ERR>NO_MODIFICATION_ALLOWED_ERR</span> = 7;
  const unsigned short <span title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</span> = 8;
  const unsigned short <span title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</span> = 9;
  const unsigned short <span title=dom-DOMException-INUSE_ATTRIBUTE_ERR>INUSE_ATTRIBUTE_ERR</span> = 10; // historical
  const unsigned short <span title=dom-DOMException-INVALID_STATE_ERR>INVALID_STATE_ERR</span> = 11;
  const unsigned short <span title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</span> = 12;
  const unsigned short <span title=dom-DOMException-INVALID_MODIFICATION_ERR>INVALID_MODIFICATION_ERR</span> = 13; // historical
  const unsigned short <span title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</span> = 14;
  const unsigned short <span title=dom-DOMException-INVALID_ACCESS_ERR>INVALID_ACCESS_ERR</span> = 15;
  const unsigned short <span title=dom-DOMException-VALIDATION_ERR>VALIDATION_ERR</span> = 16; // historical
  const unsigned short <span title=dom-DOMException-TYPE_MISMATCH_ERR>TYPE_MISMATCH_ERR</span> = 17;
  const unsigned short <span title=dom-DOMException-SECURITY_ERR>SECURITY_ERR</span> = 18;
  const unsigned short <span title=dom-DOMException-NETWORK_ERR>NETWORK_ERR</span> = 19;
  const unsigned short <span title=dom-DOMException-ABORT_ERR>ABORT_ERR</span> = 20;
  const unsigned short <span title=dom-DOMException-URL_MISMATCH_ERR>URL_MISMATCH_ERR</span> = 21;
  const unsigned short <span title=dom-DOMException-QUOTA_EXCEEDED_ERR>QUOTA_EXCEEDED_ERR</span> = 22;
  const unsigned short <span title=dom-DOMException-TIMEOUT_ERR>TIMEOUT_ERR</span> = 23;
  const unsigned short <span title=dom-DOMException-DATA_CLONE_ERR>DATA_CLONE_ERR</span> = 24;
  unsigned short <span title=dom-DOMException-code>code</span>;
  DOMString <span title=dom-DOMException-message>message</span>;
  DOMString <span title=dom-DOMException-name>name</span>;
};</pre>

<p>The <dfn title=dom-DOMException-code><code>code</code></dfn> exception member
must return the code for the exception, which must be one of the following:

<ol class="brief">
 <li value="1"><dfn title=dom-DOMException-INDEX_SIZE_ERR><code>INDEX_SIZE_ERR</code></dfn>:
 the index is not in the allowed range;
 <li value="2"><dfn title=dom-DOMException-DOMSTRING_SIZE_ERR><code>DOMSTRING_SIZE_ERR</code></dfn>:
 the text does not fit in a <code data-anolis-spec=webidl>DOMString</code>
 (historical);
 <li value="3"><dfn title=dom-DOMException-HIERARCHY_REQUEST_ERR><code>HIERARCHY_REQUEST_ERR</code></dfn>:
 the operation would not result in a <span>legal hierarchy</span>;
 <li value="4"><dfn title=dom-DOMException-WRONG_DOCUMENT_ERR><code>WRONG_DOCUMENT_ERR</code></dfn>:
 the object is in the wrong <code>Document</code>, a call to <code
 title=dom-Document-importNode>importNode</code> is required;
 <li value="5"><dfn title=dom-DOMException-INVALID_CHARACTER_ERR><code>INVALID_CHARACTER_ERR</code></dfn>:
 the string contains invalid characters;
 <li value="6"><dfn title=dom-DOMException-NO_DATA_ALLOWED_ERR><code>NO_DATA_ALLOWED_ERR</code></dfn>:
 data is specified for an object that does not support it (historical);
 <li value="7"><dfn title=dom-DOMException-NO_MODIFICATION_ALLOWED_ERR><code>NO_MODIFICATION_ALLOWED_ERR</code></dfn>:
 the object can not be modified;
 <li value="8"><dfn title=dom-DOMException-NOT_FOUND_ERR><code>NOT_FOUND_ERR</code></dfn>:
 the object can not be found here;
 <li value="9"><dfn title=dom-DOMException-NOT_SUPPORTED_ERR><code>NOT_SUPPORTED_ERR</code></dfn>:
 this operation is not supported;
 <li value="10"><dfn title=dom-DOMException-INUSE_ATTRIBUTE_ERR><code>INUSE_ATTRIBUTE_ERR</code></dfn>:
 the attribute is in use (historical)<!--createAttribute-->;
 <li value="11"><dfn title=dom-DOMException-INVALID_STATE_ERR><code>INVALID_STATE_ERR</code></dfn>:
 the object is in an invalid state;
 <li value="12"><dfn title=dom-DOMException-SYNTAX_ERR><code>SYNTAX_ERR</code></dfn>:
 the string did not match the expected pattern;
 <li value="13"><dfn title=dom-DOMException-INVALID_MODIFICATION_ERR><code>INVALID_MODIFICATION_ERR</code></dfn>:
 the object can not be modified (historical);
 <li value="14"><dfn title=dom-DOMException-NAMESPACE_ERR><code>NAMESPACE_ERR</code></dfn>:
 the operation is not allowed by <cite>Namespaces in XML</cite>; <span
 data-anolis-ref>XMLNS</span>
 <li value="15"><dfn title=dom-DOMException-INVALID_ACCESS_ERR><code>INVALID_ACCESS_ERR</code></dfn>:
 the object doesn't support the operation or argument;
 <li value="16"><dfn title=dom-DOMException-VALIDATION_ERR><code>VALIDATION_ERR</code></dfn>:
 the operation is invalid (historical);
 <li value="17"><dfn title=dom-DOMException-TYPE_MISMATCH_ERR><code>TYPE_MISMATCH_ERR</code></dfn>:
 the type of the object doesn't match the expected type;
 <!-- XHR -->
 <li value="18"><dfn title=dom-DOMException-SECURITY_ERR><code>SECURITY_ERR</code></dfn>:
 the operation is insecure;
 <!-- XHR -->
 <li value="19"><dfn title=dom-DOMException-NETWORK_ERR><code>NETWORK_ERR</code></dfn>:
 a network error occurred;
 <!-- XHR -->
 <li value="20"><dfn title=dom-DOMException-ABORT_ERR><code>ABORT_ERR</code></dfn>:
 the user aborted an operation;
 <!-- Workers -->
 <li value="21"><dfn title=dom-DOMException-URL_MISMATCH_ERR><code>URL_MISMATCH_ERR</code></dfn>:
 the given URL doesn't match another URL;
 <!-- HTML -->
 <li value="22"><dfn title=dom-DOMException-QUOTA_EXCEEDED_ERR><code>QUOTA_EXCEEDED_ERR</code></dfn>:
 the quota has been exceeded;
 <!-- XHR2 -->
 <li value="23"><dfn title=dom-DOMException-TIMEOUT_ERR><code>TIMEOUT_ERR</code></dfn>:
 a timeout occurred;
 <!-- HTML -->
 <li value="24"><dfn title=dom-DOMException-DATA_CLONE_ERR><code>DATA_CLONE_ERR</code></dfn>:
 the object can not be cloned;
</ol>

<p>The <dfn title=dom-DOMException-message><code>message</code></dfn> exception
member must return a user-agent-defined human-readable string describing the
exception.

<p>The <dfn title=dom-DOMException-name><code>name</code></dfn> exception member
must return the name of the exception constant as a string.</p>



<h2>Nodes</h2>
<h3>Interface <code>Node</code></h3>
<pre class=idl>interface <dfn>Node</dfn> {

  // NodeType
  const unsigned short <span title=dom-Node-ELEMENT_NODE>ELEMENT_NODE</span> = 1;
  const unsigned short <span title=dom-Node-ATTRIBUTE_NODE>ATTRIBUTE_NODE</span> = 2;
  const unsigned short <span title=dom-Node-TEXT_NODE>TEXT_NODE</span> = 3;
  const unsigned short <span title=dom-Node-CDATA_SECTION_NODE>CDATA_SECTION_NODE</span> = 4; // historical
  const unsigned short <span title=dom-Node-ENTITY_REFERENCE_NODE>ENTITY_REFERENCE_NODE</span> = 5; // historical
  const unsigned short <span title=dom-Node-ENTITY_NODE>ENTITY_NODE</span> = 6; // historical
  const unsigned short <span title=dom-Node-PROCESSING_INSTRUCTION_NODE>PROCESSING_INSTRUCTION_NODE</span> = 7;
  const unsigned short <span title=dom-Node-COMMENT_NODE>COMMENT_NODE</span> = 8;
  const unsigned short <span title=dom-Node-DOCUMENT_NODE>DOCUMENT_NODE</span> = 9;
  const unsigned short <span title=dom-Node-DOCUMENT_TYPE_NODE>DOCUMENT_TYPE_NODE</span> = 10;
  const unsigned short <span title=dom-Node-DOCUMENT_FRAGMENT_NODE>DOCUMENT_FRAGMENT_NODE</span> = 11;
  const unsigned short <span title=dom-Node-NOTATION_NODE>NOTATION_NODE</span> = 12; // historical

  readonly attribute DOMString <span title=dom-Node-nodeName>nodeName</span>;
           attribute DOMString <span title=dom-Node-nodeValue>nodeValue</span>;
  readonly attribute unsigned short <span title=dom-Node-nodeType>nodeType</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-parentNode>parentNode</span>;
  readonly attribute <span>Element</span> <span title=dom-Node-parentElement>parentElement</span>;
  readonly attribute <span>NodeList</span> <span title=dom-Node-childNodes>childNodes</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-firstChild>firstChild</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-lastChild>lastChild</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-previousSibling>previousSibling</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-nextSibling>nextSibling</span>;
  readonly attribute <span>NamedNodeMap</span> <span title=dom-Node-attributes>attributes</span>;
  readonly attribute <span>Document</span> <span title=dom-Node-ownerDocument>ownerDocument</span>;
  <span>Node</span> <span title=dom-Node-insertBefore>insertBefore</span>(<span>Node</span> newChild, <span>Node</span> refChild);
  <span>Node</span> <span title=dom-Node-replaceChild>replaceChild</span>(<span>Node</span> newChild, <span>Node</span> oldChild);
  <span>Node</span> <span title=dom-Node-removeChild>removeChild</span>(<span>Node</span> oldChild);
  <span>Node</span> <span title=dom-Node-appendChild>appendChild</span>(<span>Node</span> newChild);
  boolean <span title=dom-Node-hasChildNodes>hasChildNodes</span>();
  <span>Node</span> <span title=dom-Node-cloneNode>cloneNode</span>(boolean deep);<!--
  void normalize();-->
  boolean <span title=dom-Node-isSupported>isSupported</span>([TreatNullAs=EmptyString] DOMString feature, DOMString version);
  readonly attribute DOMString <span title=dom-Node-namespaceURI>namespaceURI</span>;
  readonly attribute DOMString <span title=dom-Node-prefix>prefix</span>;
  readonly attribute DOMString <span title=dom-Node-localName>localName</span>;
  boolean <span title=dom-Node-hasAttributes>hasAttributes</span>();
  readonly attribute DOMString <span title=dom-Node-baseURI>baseURI</span>;

  // DocumentPosition
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_DISCONNECTED>DOCUMENT_POSITION_DISCONNECTED</span> = 0x01;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_PRECEDING>DOCUMENT_POSITION_PRECEDING</span> = 0x02;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_FOLLOWING>DOCUMENT_POSITION_FOLLOWING</span> = 0x04;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_CONTAINS>DOCUMENT_POSITION_CONTAINS</span> = 0x08;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_CONTAINED_BY>DOCUMENT_POSITION_CONTAINED_BY</span> = 0x10;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</span> = 0x20;

  unsigned short <span title=dom-Node-compareDocumentPosition>compareDocumentPosition</span>(<span>Node</span> other);

  [TreatNullAs=EmptyString] attribute DOMString <span title=dom-Node-textContent>textContent</span>;
  boolean <span title=dom-Node-isSameNode>isSameNode</span>(<span>Node</span> other);
  DOMString <span title=dom-Node-lookupPrefix>lookupPrefix</span>(DOMString namespaceURI);
  boolean <span title=dom-Node-isDefaultNamespace>isDefaultNamespace</span>(DOMString namespaceURI);
  DOMString <span title=dom-Node-lookupNamespaceURI>lookupNamespaceURI</span>(DOMString prefix);
  boolean <span title=dom-Node-isEqualNode>isEqualNode</span>(<span>Node</span> arg);<!--
  DOMObject getFeature(DOMString feature, DOMString version);
  DOMUserData setUserData(DOMString key, DOMUserData data, UserDataHandler handler);
  DOMUserData getUserData(DOMString key);-->
};</pre>

<p>These are the constants <code title=dom-Node-nodeType>nodeType</code> (as
defined below) returns. The constants marked historical can no longer be
returned, but are still exposed.</p>

<ol>
 <li value=1><dfn title=dom-Node-ELEMENT_NODE><code>ELEMENT_NODE</code></dfn>

 <li value=2><dfn title=dom-Node-ATTRIBUTE_NODE><code>ATTRIBUTE_NODE</code></dfn>

 <li value=3><dfn title=dom-Node-TEXT_NODE><code>TEXT_NODE</code></dfn>

 <li value=4><dfn title=dom-Node-CDATA_SECTION_NODE><code>CDATA_SECTION_NODE</code></dfn> (historical)

 <li value=5><dfn title=dom-Node-ENTITY_REFERENCE_NODE><code>ENTITY_REFERENCE_NODE</code></dfn> (historical)

 <li value=6><dfn title=dom-Node-ENTITY_NODE><code>ENTITY_NODE</code></dfn> (historical)

 <li value=7><dfn title=dom-Node-PROCESSING_INSTRUCTION_NODE><code>PROCESSING_INSTRUCTION_NODE</code></dfn>

 <li value=8><dfn title=dom-Node-COMMENT_NODE><code>COMMENT_NODE</code></dfn>

 <li value=9><dfn title=dom-Node-DOCUMENT_NODE><code>DOCUMENT_NODE</code></dfn>

 <li value=10><dfn title=dom-Node-DOCUMENT_TYPE_NODE><code>DOCUMENT_TYPE_NODE</code></dfn>

 <li value=11><dfn title=dom-Node-DOCUMENT_FRAGMENT_NODE><code>DOCUMENT_FRAGMENT_NODE</code></dfn>

 <li value=12><dfn title=dom-Node-NOTATION_NODE><code>NOTATION_NODE</code></dfn> (historical)
</ol>


<p>The <dfn title=dom-Node-nodeName><code>nodeName</code></dfn>, <dfn title=dom-Node-nodeValue><code>nodeValue</code></dfn> and <dfn title=dom-Node-nodeType><code>nodeType</code></dfn> attributes must, on getting, return what is in the second, third and fourth column, respectively, if the node also implements the interface in the first column on the same row in the following table:

<table>
 <caption>Value of <code title=dom-Node-nodeName>nodeName</code>, <code
 title=dom-Node-nodeValue>nodeValue</code>, <code
 title=dom-Node-nodeType>nodeType</code></caption>
 <thead>
  <tr><th>Interface<th><code title=dom-Node-nodeName>nodeName</code><th><code title=dom-Node-nodeValue>nodeValue</code><th><code title=dom-Node-nodeType>nodeType</code>
 <tbody>
  <tr><td><code>Element</code><td>same as <code title=dom-Element-tagName>tagName</code><td>null<td>1
  <tr><td><code>Attr</code><td>same as <code title=dom-Attr-name>name</code><td>same as <code title=dom-Attr-value>value</code><td>2
  <tr><td><code>Text</code><td>"<code title>#text</code>"<td>same as <code title=dom-CharacterData-data>data</code><td>3
  <tr><td><code>ProcessingInstruction</code><td>same as <code title=dom-ProcessingInstruction-target>target</code><td>same as <code title=dom-ProcessingInstruction-data>data</code><td>7
  <tr><td><code>Comment</code><td>"<code title>#comment</code>"<td>same as <code title=dom-CharacterData-data>data</code><td>8
  <tr><td><code>Document</code><td>"<code title>#document</code>"<td>null<td>9
  <tr><td><code>DocumentType</code><td>same as <code title=dom-DocumentType-name>name</code><td>null<td>10
  <tr><td><code>DocumentFragment</code><td>"<code title>#document-fragment</code>"<td>null<td>11
</table>

<p>The <dfn title=dom-Node-parentNode><code>parentNode</code></dfn> attribute
must, on getting, run the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <code>Attr</code> node, return
 null and abort these steps.

 <li><p>If the <span>context node</span> doesn't have a parent node, return
 null and abort these steps.

 <li><p>Return the parent node of the <span>context node</span>.
</ol>

<!-- XXX really needed? Minefield does not have this -->
<p>The <dfn title=dom-Node-parentElement><code>parentElement</code></dfn> attribute must, on getting, return the parent node of the <span>context node</span> if there is a parent and it is an element, or null otherwise.

<p>The <dfn title=dom-Node-childNodes><code>childNodes</code></dfn> attribute must, on getting, return a <code>NodeList</code> rooted at the <span>context node</span> matching only child nodes.

<p>The <dfn title=dom-Node-firstChild><code>firstChild</code></dfn> attribute must, on getting, return the first child node of the <span>context node</span>, or null if there is none.

<p>The <dfn title=dom-Node-lastChild><code>lastChild</code></dfn> attribute must, on getting, return the last child node of the <span>context node</span>, or null if there is none.

<p>The <dfn title=dom-Node-previousSibling><code>previousSibling</code></dfn>
attribute must, on getting, run the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <code>Attr</code> node, return
 null and abort these steps.

 <li><p>If the <span>context node</span> doesn't have a previous sibling node,
 return null and abort these steps.

 <li><p>Return the previous sibling node of the <span>context node</span>.
</ol>

<p>The <dfn title=dom-Node-nextSibling><code>nextSibling</code></dfn> attribute
must, on getting, run the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <code>Attr</code> node, return
 null and abort these steps.

 <li><p>If the <span>context node</span> doesn't have a next sibling node,
 return null and abort these steps.

 <li><p>Return the next sibling node of the <span>context node</span>.
</ol>

<p>The <dfn title=dom-Node-attributes><code>attributes</code></dfn> attribute must, on getting, return a <code>NamedNodeMap</code> of all the <code>Attr</code> nodes associated with the node of the <span>context node</span>, if it is an <code>Element</code> node, or null otherwise.

<p>The <dfn title=dom-Node-ownerDocument><code>ownerDocument</code></dfn> attribute must, on getting, return the <code>Document</code> node that the <span>context node</span> is associated with, or null if there is none.

<p>The <dfn title=dom-Node-insertBefore><code>insertBefore(<var
title>newChild</var>, <var>refChild</var>)</code></dfn> method must run
the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <code>Attr</code> node or a
 <code>Text</code> node, then raise a <code
 title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code> and
 abort these steps. <!-- See Mozilla bug 547798, 558973 -->

 <li><p>If <var>newChild</var> is null, then raise a <code
 title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception and
 abort these steps.

 <li><p>If <var>refChild</var> is not null and is not a child of the
 <span>context node</span>, then raise a <code
 title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</code> exception and abort
 these steps. <!-- Do not adopt. -->

 <li><p>If <var>newChild</var>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code> is not equal to the
 <span>context node</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>, call the
 <span>context node</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <code title=dom-Document-adoptNode>adoptNode</code> method with
 <var>newChild</var> as its argument.

 <!-- no security check -->
 <li><p>If <var>newChild</var> is a <code>DocumentFragment</code> node,
 then while <var>newChild</var>'s <code
 title=dom-Node-firstChild>firstChild</code> is not null, call <code
 title=dom-Node-insertBefore>insertBefore</code> on the <span>context
 node</span> with <var>newChild</var>'s <code
 title=dom-Node-firstChild>firstChild</code> as first argument and <var
 title>refChild</var> as second argument.

 <li><p>Otherwise, if <var>refChild</var> is null, append <var
 title>newChild</var> to the <span>context node</span>.

 <li><p>Otherwise insert <var>newChild</var> in the <span>context
 node</span> as the previous sibling of <var>refChild</var>.

 <li><p>Return <var>newChild</var>.
</ol>

<p>The <dfn title=dom-Node-replaceChild><code>replaceChild(<var
title>newChild</var>, <var>oldChild</var>)</code></dfn> method must run
the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <code>Attr</code> node or a
 <code>Text</code> node, then raise a <code
 title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code> and
 abort these steps. <!-- See Mozilla bug 547798, 558973 -->

 <li><p>If either <var>newChild</var> or <var>oldChild</var> is
 null, then raise a <code
 title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception and
 abort these steps.

 <li><p>If <var>newChild</var>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code> is not equal to the
 <span>context node</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>, call the
 <span>context node</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <code title=dom-Document-adoptNode>adoptNode</code> method with
 <var>newChild</var> as its argument.

 <li><p>If <var>oldChild</var> is not a child of the <span>context
 node</span>, then raise a <code
 title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</code>
 exception and abort these steps.

 <!-- no security check -->
 <li><p>Let <var>refChild</var> be <var>oldChild</var>'s
 <code title=dom-Node-nextSibling>nextSibling</code>.

 <li><p>Remove <var>oldChild</var> from <span>context node</span>.

 <li><p>Call <code title=dom-Node-insertBefore>insertBefore</code> on the
 <span>context node</span> with <var>newChild</var> and <var
 title>refChild</var> as arguments, respectively.

 <li><p>Return <var>newChild</var>.
</ol>

<p>The <dfn
title=dom-Node-removeChild><code>removeChild(<var
title>oldChild</var>)</code></dfn> method must run the following steps:

<ol>
 <!-- Attr nodes are okay -->
 <li><p>If <var>oldChild</var> is null, then raise a <code
 title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception and
 abort these steps.

 <li><p>If <var>oldChild</var> is not a child of the <span>context
 node</span>, then raise a <code
 title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</code> exception and abort
 these steps.
 <!-- Including other documents. -->

 <li><p>Remove <var>oldChild</var> from <span>context node</span>.

 <li><p>Return <var>oldChild</var>.
</ol>

<p>The <dfn
title=dom-Node-appendChild><code>appendChild(<var
title>newChild</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <code>Attr</code> node or a
 <code>Text</code> node, then raise a <code
 title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code> and
 abort these steps. <!-- See Mozilla bug 547798, 558973 -->

 <li><p>If <var>newChild</var> is null, then raise a <code
 title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception and
 abort these steps.

 <li><p>If <var>newChild</var>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code> is not equal to the
 <span>context node</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>, call the
 <span>context node</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <code title=dom-Document-adoptNode>adoptNode</code> method with
 <var>newChild</var> as its argument.

 <!-- no security check -->
 <li><p>Append <var>newChild</var> to the <span>context node</span>.

 <li><p>Return <var>newChild</var>.
</ol>

<p>The <dfn title=dom-Node-hasChildNodes><code>hasChildNodes()</code></dfn> method must return false if the <span>context node</span>'s <code title=dom-Node-firstChild>firstChild</code> is null, and true otherwise.

<p>The <dfn title=dom-Node-cloneNode><code>cloneNode(<var
title>deep</var>)</code></dfn> method must return a <span>clone</span> of the
<span>context node</span>, with <var>new ownerDocument</var> being the
<span>context node</span>'s <code
title=dom-Node-ownerDocument>ownerDocument</code>, and the <var>clone
children</var> flag set if <var>deep</var> is true.

<p>The <dfn title=dom-Node-isSupported><code>isSupported(<var
title>feature</var>, <var>version</var>)</code></dfn> method must return
true if the user agent <span title=concept-support-DOMfeatureversion>supports</span>
the (<var>feature</var>, <var>version</var>) tuple on the
<span>context node</span>, and false otherwise.

<p>The <dfn title=dom-Node-namespaceURI><code>namespaceURI</code></dfn> attribute must return the namespace that is associated with the node, if there is one and it's not the empty string, or null otherwise.

<p>The <dfn title=dom-Node-prefix><code>prefix</code></dfn> attribute must return the prefix that is associated with the node, if there is one and it's not the empty string, or null otherwise.
<!--XXX support setting? - - On setting, it must run the following steps:

<ol>
 <li><p>Let <var>prefix</var> be the value being assigned.
 <li>
  <p>If <var>prefix</var> is not null, run the following substeps:
  <ol>
   <li><p>If <var>prefix</var> doesn't match the <code data-anolis-spec=xml>Name</code> production in XML, raise an <code title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and abort these steps.
   <li><p>If <var>prefix</var> doesn't match the <code
   data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, raise a
   <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and
   abort these steps.
  </ol>
 <li><p class=XXX>Actually this doesn't match any browser. Let's try to drop it instead.
</ol>-->

<p class=note>Setting the <code title=dom-Node-prefix>prefix</code> attribute is
no longer supported.

<p>The <dfn title=dom-Node-localName><code>localName</code></dfn> attribute must return the local name that is associated with the node, if it has
one, and null otherwise.

<p>The <dfn title=dom-Node-hasAttributes><code>hasAttributes()</code></dfn>
method must return whether there are any attributes associated with the
<span>context node</span>, if it is an <code>Element</code> node, and false
otherwise.

<p>The <dfn title=dom-Node-baseURI><code>baseURI</code></dfn> attribute must <span class=XXX title>...</span>

<hr>

<p>These are the constants
<code title=dom-Node-compareDocumentPosition>compareDocumentPosition()</code>
returns.</p>

<ol>
 <li value=1><dfn title=dom-Node-DOCUMENT_POSITION_DISCONNECTED><code>DOCUMENT_POSITION_DISCONNECTED</code></dfn>

 <li value=2><dfn title=dom-Node-DOCUMENT_POSITION_PRECEDING><code>DOCUMENT_POSITION_PRECEDING</code></dfn>

 <li value=4><dfn title=dom-Node-DOCUMENT_POSITION_FOLLOWING><code>DOCUMENT_POSITION_FOLLOWING</code></dfn>

 <li value=8><dfn title=dom-Node-DOCUMENT_POSITION_CONTAINS><code>DOCUMENT_POSITION_CONTAINS</code></dfn>

 <li value=16><dfn title=dom-Node-DOCUMENT_POSITION_CONTAINED_BY><code>DOCUMENT_POSITION_CONTAINED_BY</code></dfn>

 <li value=32><dfn title=dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC><code>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></dfn>
</ol>

<p>The <dfn
title=dom-Node-compareDocumentPosition><code>compareDocumentPosition(<var
title>other</var>)</code></dfn> method must <span class=XXX title>...</span>
<!-- XXX @beverloo might figure this out; remove impl specific? -->

<hr>


<p>The <dfn title=dom-Node-textContent><code>textContent</code></dfn> attribute, on getting, must return a concatenation of the <code title=dom-CharacterData-data>data</code> of all the descendant <code>Text</code> nodes of the <span>context node</span>, in <span>tree order</span>. On setting, it must run the following steps:

<ol>
 <li><p>Remove all the child nodes of the <span>context node</span>.
 <li><p>Let <var>data</var> be the value being assigned.
 <li><p>If <var>data</var> is not the empty string, append a new <code>Text</code> node to the <span>context node</span> whose <code title=dom-CharacterData-data>data</code> is set to <var>data</var>.
</ol>

<p class=XXX>What does null mean? <a href="http://www.w3.org/mid/c9e12660808271343v58990698gabac29d2123a82ce@mail.gmail.com">http://www.w3.org/mid/c9e12660808271343v58990698gabac29d2123a82ce@mail.gmail.com</a>

<p>The <dfn title=dom-Node-isSameNode><code>isSameNode(<var
title>other</var>)</code></dfn> method must return true if <var
title>other</var> is a reference to the same object as the <span>context
node</span>, and false otherwise.

<p>The <dfn title=dom-Node-lookupPrefix><code>lookupPrefix(<var
title>namespaceURI</var>)</code></dfn> method must <span class=XXX title>...</span>

<p>The <dfn title=dom-Node-isDefaultNamespace><code>isDefaultNamespace(<var
title>namespaceURI</var>)</code></dfn> method must <span class=XXX title>...</span>

<p>The <dfn title=dom-Node-lookupNamespaceURI><code>lookupNamespaceURI(<var
title>prefix</var>)</code></dfn> method must <span class=XXX title>...</span>

<p class=XXX>clarify lookupNamespaceURI <a href=http://www.w3.org/mid/4878DFC6.40401@lachy.id.au>http://www.w3.org/mid/4878DFC6.40401@lachy.id.au</a>; lookupNamespaceURI, isDefaultNamespace <a href="http://html5.org/tools/web-apps-tracker?from=2125&amp;to=2126">http://html5.org/tools/web-apps-tracker?from=2125&amp;to=2126</a>

<p>The <dfn title=dom-Node-isEqualNode><code>isEqualNode(<var
title>arg</var>)</code></dfn> method must return true if all of the following
conditions are true, and must otherwise return false:

<ul>
 <li><p><var>arg</var> is not null.
 <li><p><var>arg</var>'s <code title=dom-Node-nodeType>nodeType</code> is the same as the <span>context node</span>'s <code title=dom-Node-nodeType>nodeType</code>.
 <li><p><var>arg</var>'s <code title=dom-Node-nodeName>nodeName</code> is the same as the <span>context node</span>'s <code title=dom-Node-nodeName>nodeName</code>.
 <li><p><var>arg</var>'s <code title=dom-Node-localName>localName</code> is the same as the <span>context node</span>'s <code title=dom-Node-localName>localName</code>.
 <li><p><var>arg</var>'s <code title=dom-Node-namespaceURI>namespaceURI</code> is the same as the <span>context node</span>'s <code title=dom-Node-namespaceURI>namespaceURI</code>.
 <li><p><var>arg</var>'s <code title=dom-Node-prefix>prefix</code> is the same as the <span>context node</span>'s <code title=dom-Node-prefix>prefix</code>.
 <li><p><var>arg</var>'s <code title=dom-Node-nodeValue>nodeValue</code> is the same as the <span>context node</span>'s <code title=dom-Node-nodeValue>nodeValue</code>.

 <li><p>Either <var>arg</var>'s <code
 title=dom-Node-attributes>attributes</code> and the <span>context node</span>'s
 <code title=dom-Node-attributes>attributes</code> are both null or a bijection
 exists between the set of <var>arg</var>'s <code
 title=dom-Node-attributes>attributes</code> and the set of the <span>context
 node</span>'s <code title=dom-Node-attributes>attributes</code> so that every
 <code>Attr</code> node in the former is mapped to an <code>Attr</code> node in
 the latter for which calling <code
 title=dom-Node-isEqualNode>isEqualNode</code> on the first <code>Attr</code>
 node with the second <code>Attr</code> node as its argument returns true.

 <li><p><var>arg</var>'s <code title=dom-Node-childNodes>childNodes</code>' <code title=dom-NodeList-length>length</code> is the same as the <span>context node</span>'s <code title=dom-Node-childNodes>childNodes</code>' <code title=dom-NodeList-length>length</code>.
 <li><p>Calling <code title=dom-Node-isEqualNode>isEqualNode</code> on each child node of the <span>context node</span>, with the child node of the same index in <var>arg</var> as argument returns true for every child node.
</ul>


<h3>Interface <code>DocumentFragment</code></h3>
<pre class=idl>interface <dfn>DocumentFragment</dfn> : <span>Node</span> {
};</pre>


<h3>Interface <code>Document</code></h3>
<pre class=idl>interface <dfn>Document</dfn> : <span>Node</span> {
  readonly attribute <span>DocumentType</span> <span title=dom-Document-doctype>doctype</span>;
  readonly attribute <span>DOMImplementation</span> <span title=dom-Document-implementation>implementation</span>;
  readonly attribute <span>Element</span> <span title=dom-Document-documentElement>documentElement</span>;

  <span>Element</span> <span title=dom-Document-createElement>createElement</span>([TreatNullAs=EmptyString] DOMString <var>localName</var>);
  <span>Element</span> <span title=dom-Document-createElementNS>createElementNS</span>(DOMString namespaceURI, DOMString qualifiedName);
  <span>DocumentFragment</span> <span title=dom-Document-createDocumentFragment>createDocumentFragment</span>();
  <span>Text</span> <span title=dom-Document-createTextNode>createTextNode</span>(DOMString <var>data</var>);
  <span>Comment</span> <span title=dom-Document-createComment>createComment</span>(DOMString <var>data</var>);
  <span>ProcessingInstruction</span> <span title=dom-Document-createProcessingInstruction>createProcessingInstruction</span>(DOMString <var>target</var>, DOMString <var>data</var>);<!--
  CDATASection createCDATASection(DOMString data);
  EntityReference createEntityReference(DOMString name);
  <span>Attr</span> <span title=dom-Document-createAttribute>createAttribute</span>(DOMString name);
  <span>Attr</span> <span title=dom-Document-createAttributeNS>createAttributeNS</span>(DOMString namespaceURI, DOMString qualifiedName);
    If adding this, search for [createAttribute]-->

  <span>NodeList</span> <span title=dom-Document-getElementsByTagName>getElementsByTagName</span>(DOMString <var>qualifiedName</var>);
  <span>NodeList</span> <span title=dom-Document-getElementsByTagNameNS>getElementsByTagNameNS</span>(DOMString <var>namespaceURI</var>, DOMString <var>localName</var>);
  <span>NodeList</span> <span title=dom-Document-getElementsByClassName>getElementsByClassName</span>(DOMString <var>classNames</var>);
  <span>Element</span> <span title=dom-Document-getElementById>getElementById</span>(DOMString <var>elementId</var>);

  <span>Node</span> <span title=dom-Document-importNode>importNode</span>(<span>Node</span> <var>importedNode</var>, boolean <var>deep</var>);
  <span>Node</span> <span title=dom-Document-adoptNode>adoptNode</span>(<span>Node</span> <var>source</var>);

  readonly attribute DOMString <span title=dom-Document-inputEncoding>inputEncoding</span>;
           attribute DOMString <span title=dom-Document-documentURI>documentURI</span>;
  readonly attribute DOMString <span title=dom-Document-compatMode>compatMode</span>;<!--
  readonly attribute DOMString xmlEncoding;
           attribute boolean xmlStandalone;
           attribute DOMString <span title=dom-Document-xmlVersion>xmlVersion</span>;
           attribute boolean strictErrorChecking;
  readonly attribute DOMConfiguration domConfig;
  void normalizeDocument();
  Node renameNode(Node n, DOMString namespaceURI, DOMString qualifiedName);-->
};</pre>

<p>A <code>Document</code> node is assumed to be an <dfn>XML document</dfn>
unless it is flagged as being an <dfn>HTML document</dfn>. Whether a
document is an <span>HTML document</span> or an <span>XML document</span>
affects the behavior of certain APIs.

<p>A <code>Document</code> node is always set to one of three modes:
<dfn title=concept-no-quirks-mode>no-quirks mode</dfn>, the default;
<dfn title=concept-quirks-mode>quirks mode</dfn>, used typically for legacy
documents; and
<dfn title=concept-limited-quirks-mode>limited-quirks mode</dfn>, also known
as "almost standards" mode. Unless
<span>other applicable specifications</span> define otherwise, the
<code>Document</code> must be in
<span title=concept-no-quirks-mode>no-quirks mode</span>.

<p class=note>The mode is only ever changed from the default if the
<code>Document</code> node is created by the
<span data-anolis-spec=html>HTML parser</span>, based on the presence,
absence, or value of the DOCTYPE string.
<span data-anolis-ref class=informative>HTML</span>

<p>The <dfn title=dom-Document-doctype><code>doctype</code></dfn> attribute must return the first child of the <code>Document</code> node that is a <code>DocumentType</code> node, if there is one, or null otherwise.

<p class=note>In both HTML and XML there will only ever be one
<code>DocumentType</code> node descendant of the <code>Document</code> node.
<span data-anolis-ref class=informative>HTML</span> <span data-anolis-ref
class=informative>XML</span>

<p>The <dfn title=dom-Document-implementation><code>implementation</code></dfn> attribute must return the <code>DOMImplementation</code> object that is associated with the <code>Document</code> node.

<p>The <dfn title=dom-Document-documentElement><code>documentElement</code></dfn> attribute must return the first child of the <code>Document</code> node that is an <code>Element</code> node, if there is one, or null otherwise.

<hr>

<p>The <dfn title=dom-Document-createElement><code>createElement(<var>localName</var>)</code></dfn> method must run the these steps:</p>

<ol>
 <li><p>If <var>localName</var> does not match the <code
 data-anolis-spec=xml>Name</code> production in XML, raise an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li><p>If the <span>context node</span> is an <span>HTML document</span>,
 let <var>localName</var> be <var>localName</var>,
 <span>converted to lowercase</span>.
 <!-- XXX why not do this everywhere? -->

 <li><p>Return a new <code>Element</code> node with no attributes,
 <code title=dom-Node-namespaceURI>namespaceURI</code> set to the
 <span>HTML namespace</span>, <code title=dom-Node-prefix>prefix</code> set
 to null, <code title=dom-Node-localName>localName</code> set to
 <var>localName</var>, and
 <code title=dom-Node-ownerDocument>ownerDocument</code> set to the
 <span>context node</span>.
</ol>
<!-- this is very different from DOM3 -->
<p class=note>No check is performed that the local name will match the
<code data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML.

<p>The <dfn title=dom-Document-createElementNS><code>createElementNS(<var>namespaceURI</var>, <var>qualifiedName</var>)</code></dfn> method must run these steps:</p>
<ol>
 <li><p>If <var>qualifiedName</var> doesn't match the <code
 data-anolis-spec=xml>Name</code> production in XML, raise an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and abort these steps.
 <li><p>If <var>qualifiedName</var> doesn't match the <code
 data-anolis-spec=xmlns>QName</code> production in Namespaces in XML, raise a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and
 abort these steps.
 <li><p>If <var>qualifiedName</var> contains a "<code>:</code>" (U+003E),
 then split the string on it and let <var>prefix</var> be the part before
 and <var>localName</var> the part after. Otherwise, let <var>prefix</var>
 be null and <var>localName</var> be <var>qualifiedName</var>.
 <li><p>If <var>prefix</var> is not null and <var>namespaceURI</var> is an empty string, raise a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and abort these steps.
 <li><p>If <var>prefix</var> is "xml" and <var>namespaceURI</var> is not the <span>XML namespace</span>, raise a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and abort these steps.
 <li><p>If <var>qualifiedName</var> or <var>prefix</var> is "xmlns" and <var>namespaceURI</var> is not the <span>XMLNS namespace</span>, raise a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and abort these steps.
 <li><p>If <var>namespaceURI</var> is the <span>XMLNS namespace</span> and neither <var>qualifiedName</var> nor <var>prefix</var> is "xmlns", raise a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and abort these steps.
 <li><p>Return a new <code>Element</code> node with no attributes, <code title=dom-Node-namespaceURI>namespaceURI</code> set to <var>namespaceURI</var>, <code title=dom-Node-prefix>prefix</code> set to <var>prefix</var>, <code title=dom-Node-localName>localName</code> set to <var>localName</var>, and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context node</span>.
</ol>

<p>The
<dfn title=dom-Document-createDocumentFragment><code>createDocumentFragment()</code></dfn>
method must return a new <code>DocumentFragment</code> node with its
<code title=dom-Node-ownerDocument>ownerDocument</code> set to the
<span>context node</span>.

<p>The <dfn title=dom-Document-createTextNode><code>createTextNode(<var>data</var>)</code></dfn> method must return a new <code>Text</code> node with its <code title=dom-CharacterData-data>data</code> attribute set to <var>data</var> and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context node</span>.
<p class=note>No check is performed that the text node contains characters that
match the <code data-anolis-spec=xml>Char</code> production in XML.

<p>The <dfn title=dom-Document-createComment><code>createComment(<var>data</var>)</code></dfn> method must return a new <code>Comment</code> node with its <code title=dom-CharacterData-data>data</code> attribute set to <var>data</var> and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context node</span>.
<p class=note>No check is performed that the comment contains characters that
match the <code data-anolis-spec=xml>Char</code> production in XML or that it
contains two adjacent hyphens or ends with a hyphen.

<p>The <dfn title=dom-Document-createProcessingInstruction><code
>createProcessingInstruction(<var>target</var>, <var
title>data</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>If the <span>context node</span> is an <span>HTML document</span>, raise
 a <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code>
 exception and abort these steps.

 <li><p>If <var>target</var> doesn't match the <!--<code
 data-anolis-spec=xml>PITarget</code>--> <code data-anolis-spec=xml>Name</code>
 production in XML, raise an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and abort these steps. <!-- DOM3 didn't check for "xml" -->

 <li><p>If <var>data</var> contains the string "<code title>?></code>",
 raise an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and abort these steps. <!-- Gecko does this. -->

 <!--<li><p>If <var>target</var> contains a U+003A COLON (":") character, raise a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and abort these steps.--> <!-- DOM3 didn't check this -->

 <li><p>Return a new <span title=concept-PI>processing instruction</span>, with
 <var>target</var> as its <span title=concept-PI-target>target</span> and
 <var>data</var> as its <span title=concept-PI-data>data</span>, and whose
 <code title=dom-Node-ownerDocument>ownerDocument</code> is set to the
 <span>context node</span>.
</ol>

<p class=note>No check is performed that the processing instruction target
contains "xml" or the colon, or that the data contains characters that match the
<code data-anolis-spec=xml>Char</code> production in XML.</p>

<!--
[createAttribute]
<p>The <dfn title=dom-Document-createAttribute><code>createAttribute(<var>name</var>)</code></dfn> method must run the following steps:</p>
<ol>
 <li><p>If <var>name</var> doesn't match the <code data-anolis-spec=xml>Name</code> production in XML, raise an <code title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and abort these steps.
 <li><p>Return a new <code>Attr</code> node with its <code title=dom-Node-namespaceURI>namespaceURI</code> set to null, <code title=dom-Node-prefix>prefix</code> set to null, <code title=dom-Node-localName>localName</code> set to <var>name</var>, and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context node</span>.
</ol>-->
<!-- this is different from DOM3 -->
<!--<p class=note>No check is performed that the local name will match the <code
data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML.-->

<hr>
<dl class=domintro>
 <dt><var>collection</var> = <var>document</var> . <code
 title=dom-Document-getElementsByClassName>getElementsByClassName(<var
 title>classes</var>)</code>
 <dt><var>collection</var> = <var>element</var> . <code
 title=dom-Element-getElementsByClassName>getElementsByClassName(<var
 title>classes</var>)</code>
 <dd>
  <p>Returns a <code>NodeList</code> of the elements in the object
  on which the method was invoked (a <code>Document</code> or an
  <code>Element</code>) that have all the classes given by <var
  title="">classes</var>.
  <p>The <var title="">classes</var> argument is interpreted as a
  space-separated list of classes.
</dl>

<p>The <dfn
title=dom-Document-getElementsByTagName><code>getElementsByTagName(<var
title>qualifiedName</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>If <var>qualifiedName</var> is "<code>*</code>" (U+002A),
 return a <code>NodeList</code> rooted at the <span>context node</span>,
 whose filter matches only <code>Element</code> nodes.

 <li>
  <p>Otherwise, if the <span>context node</span> is an
  <span>HTML document</span>, return a <code>NodeList</code> rooted at the
  <span>context node</span>, whose filter matches only the following nodes:

  <ul>
   <li><code>Element</code> nodes in the <span>HTML namespace</span> whose <code title=dom-Node-tagName>tagName</code> is
   <var>qualifiedName</var>, <span>converted to lowercase</span>.

   <li><code>Element</code> nodes, <em>not</em> in the
   <span>HTML namespace</span>, whose
   <code title=dom-Element-tagName>tagName</code> is
   <var>qualifiedName</var>.
  </ul>

 <li><p>Otherwise, return a <code>NodeList</code> rooted at the
 <span>context node</span>, whose filter matches only <code>Element</code>
 nodes whose <code title=dom-Element-tagName>tagName</code> is
 <var>qualifiedName</var>.
</ol>

<p>A new <code>NodeList</code> object must be returned each time.

<p class=note>Thus, in an <span>HTML document</span>, <code
title>document.getElementsByTagName("FOO")</code> will match <code
title>FOO</code> elements that aren't in the <span>HTML namespace</span>, and
<code title>foo</code> elements that are in the <span>HTML namespace</span>, but
not <code title>FOO</code> elements that are in the <span>HTML namespace</span>.


<p>The <dfn title=dom-Document-getElementsByTagNameNS><code>getElementsByTagNameNS(<var>namespaceURI</var>, <var>localName</var>)</code></dfn> method must run the following steps:
<ol>
 <li><p>If both <var>namespaceURI</var> and <var>localName</var> are just the character U+002A ASTERISK ("*"), return a <code>NodeList</code> rooted at the <span>context node</span>, whose filter matches only <code>Element</code> nodes.
 <li><p>Otherwise, if <var>namespaceURI</var> is just the character U+002A ASTERISK ("*"), return a <code>NodeList</code> rooted at the <span>context node</span>, whose filter matches only <code>Element</code> nodes with the <code title=dom-Node-localName>localName</code> equal to <var>localName</var>.
 <li><p>Otherwise, if <var>localName</var> is just the character U+002A ASTERISK ("*"), return a <code>NodeList</code> rooted at the <span>context node</span>, whose filter matches only <code>Element</code> nodes with the <code title=dom-Node-namespaceURI>namespaceURI</code> equal to <var>namespaceURI</var>.
 <li><p>Otherwise, return a <code>NodeList</code> rooted at the <span>context node</span>, whose filter matches only <code>Element</code> nodes that have a <code title=dom-Node-namespaceURI>namespaceURI</code> equal to <var>namespaceURI</var> and a <code title=dom-Node-localName>localName</code> equal to <var>localName</var> (both in a <span>case-sensitive</span> manner).
</ol>
<p>A new <code>NodeList</code> object must be returned each time.


<p>The <dfn
title=dom-Document-getElementsByClassName><code>getElementsByClassName(<var
title>classNames</var>)</code></dfn> method takes a string that contains a
<span>set of space-separated tokens</span> representing <span
title=concept-class>classes</span>. When called, the method must return a <span
title=concept-collection-live>live</span> <code>NodeList</code> object
containing all the elements in the <span>context node</span>, in <span>tree
order</span>, that have all the <span title=concept-class>classes</span>
specified in the <var>classNames</var> argument, having obtained the
<span title=concept-class>classes</span> by <span title="split a string on
spaces">splitting the string on spaces</span>. (Duplicates are ignored.) If
there are no tokens specified in the argument, then the method must return an
empty <code>NodeList</code>. If the document is in <span
title=concept-quirks-mode>quirks mode</span>, then the comparisons for the <span
title=concept-class>classes</span> must be done in an <span>ASCII
case-insensitive</span> manner, otherwise, the comparisons must be done in a
<span>case-sensitive</span> manner.
<p>A new <code>NodeList</code> object must be returned each time.

<div class="example">
 <p>Given the following XHTML fragment:</p>

 <pre>&lt;div id="example"&gt;
  &lt;p id="p1" class="aaa bbb"/&gt;
  &lt;p id="p2" class="aaa ccc"/&gt;
  &lt;p id="p3" class="bbb ccc"/&gt;
&lt;/div&gt;</pre>

 <p>A call to <code
 title=dom-Element-getElementsByClassName>document.getElementById('example').getElementsByClassName('aaa')</code>
 would return a <code>NodeList</code> with the two paragraphs <code
 title="">p1</code> and <code title="">p2</code> in it.</p>

 <p>A call to <code
 title=dom-Element-getElementsByClassName>getElementsByClassName('ccc&nbsp;bbb')</code> would only
 return one node, however, namely <code title="">p3</code>. A call
 to <code
 title=dom-Element-getElementsByClassName>document.getElementById('example').getElementsByClassName('bbb&nbsp;&nbsp;ccc&nbsp;')</code>
 would return the same thing.</p>

 <p>A call to <code
 title=dom-Element-getElementsByClassName>getElementsByClassName('aaa,bbb')</code> would return no
 nodes; none of the elements above are in the "aaa,bbb" class.</p>
</div>

<!-- v2:
>         * xGetParentElementByClassName(rootElement, className, tagName) -
> Navigates upwards until we hit a parent element with the given class name and
> optional tag name.
-->


<p>The <dfn title=dom-Document-getElementById><code>getElementById(<var
title>elementId</var>)</code></dfn> method must return the first
<code>Element</code> node, in <span>tree order</span>, in the <span>context
node</span> whose <span title=concept-ID>ID</span> is <var>elementId</var>,
or null if there is none.

<hr>

<p>The <dfn title=dom-Document-importNode><code>importNode(<var>importedNode</var>, <var>deep</var>)</code></dfn> method must run
the following steps:
<ol>
 <!-- Similar text for adoptNode -->
 <li><p>If the <span>context node</span> is an <span>XML document</span>, then
 if <var>importedNode</var> or any of its descendant nodes or any of its
 <code title=dom-Node-attributes>attributes</code> or any of the <code
 title=dom-Node-attributes>attributes</code> of any descendant
 <code>Element</code> nodes has a <code
 title=dom-Node-localName>localName</code><!-- or <code
 title=dom-Node-prefix>prefix</code>--> which either does not match the <code
 data-anolis-spec=xml>Name</code> production in XML or contains a U+003A COLON
 (":") character, raise an <code
 title=dom-DOMException-INVALID_STATE_ERR>INVALID_STATE_ERR</code> and abort
 these steps.

 <li><p>Return a <span>clone</span> of <var>importedNode</var>, with <var>new ownerDocument</var> being the <span>context node</span>, and the <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<p>The <dfn title=dom-Document-adoptNode><code>adoptNode(<var>source</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>If <var>source</var> is a <code>Document</code> node or a
 <code>DocumentType</code> node, raise a <code
 title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> exception and
 abort these steps.

 <!-- Similar text for importNode -->
 <li><p>If the <span>context node</span> is an <span>XML document</span>, then
 if <var>source</var> or any of its descendant nodes or any of its <code
 title=dom-Node-attributes>attributes</code> or any of the <code
 title=dom-Node-attributes>attributes</code> of any descendant
 <code>Element</code> nodes has a <code
 title=dom-Node-localName>localName</code><!-- or <code
 title=dom-Node-prefix>prefix</code>--> which either does not match the <code
 data-anolis-spec=xml>Name</code> production in XML or contains a U+003A COLON
 (":") character, raise an <code
 title=dom-DOMException-INVALID_STATE_ERR>INVALID_STATE_ERR</code> and abort
 these steps.

 <li><p>If <var>source</var> is an <code>Element</code> node, it is
 <span>affected by a base URL change</span>.

 <!-- no security check -->
 <li><p>If <var>source</var>'s <code
 title=dom-Node-parentNode>parentNode</code> is not null and its <code
 title=dom-Node-ownerDocument>ownerDocument</code> isn't equal to the
 <span>context node</span>, remove <var>source</var> from its parent.

 <li><p>Set <var>source</var>'s <code
 title=dom-Node-ownerDocument>ownerDocument</code> to the <span>context
 node</span>.

 <li><p>If <var>source</var> is an <code>Element</code> node,
 set the <code title=dom-Node-ownerDocument>ownerDocument</code> of all
 <code>Attr</code> in its <code title=dom-Node-attributes>attributes</code>
 to the <span>context node</span>.

 <li><p>For each child node of <var>source</var>, call <code
 title=dom-Document-adoptNode>adoptNode</code> on the <span>context node</span>,
 with the child node as its argument.

 <li><p>Return <var>source</var>.
</ol>

<hr>

<dl class=domintro>
 <dt><var>document</var> . <code title=dom-Document-compatMode>compatMode</code>
 <dd>
  <p>Returns the string "<code title>CSS1Compat</code>" if the <span>context
  node</span> is in <span title=concept-no-quirks-mode>no-quirks mode</span> or
  <span title=concept-limited-quirks-mode>limited-quirks mode</span>, and
  "<code title>BackCompat</code>", if the <code>Document</code> is in
  <span title=concept-quirks-mode>quirks mode</span>.
</dl>

<p class=XXX><dfn title=dom-Document-inputEncoding>inputEncoding</dfn>
<p class=XXX>define HTML5 concept of document character encoding here

<p class=XXX><dfn title=dom-Document-documentURI>documentURI</dfn>
Should document.documentURI really exist? be readonly?

<p>The <dfn title=dom-Document-compatMode><code>compatMode</code></dfn> IDL
attribute must return the literal string "<code title>CSS1Compat</code>" unless
the <span>context node</span> is in <span
title=concept-quirks-mode>quirks mode</span>, in which case it must instead
return the literal string "<code title>BackCompat</code>".

<!-- <dfn title=dom-Document-xmlVersion>xmlVersion</dfn>
http://lists.w3.org/Archives/Public/www-dom/2003JulSep/0049.html -->


<h4>Interface <code>DOMImplementation</code></h4>
<p>User agents must create a new <code>DOMImplementation</code> object whenever a new <code>Document</code> node is created and associate it with the that <code>Document</code> node.

<pre class=idl>interface <dfn>DOMImplementation</dfn> {
  boolean <span title=dom-DOMImplementation-hasFeature>hasFeature</span>(DOMString feature, [TreatNullAs=EmptyString] DOMString version);

  <span>DocumentType</span> <span title=dom-DOMImplementation-createDocumentType>createDocumentType</span>([TreatNullAs=EmptyString] DOMString qualifiedName, DOMString publicId, DOMString systemId);
  <span>Document</span> <span title=dom-DOMImplementation-createDocument>createDocument</span>([TreatNullAs=EmptyString] DOMString namespaceURI, [TreatNullAs=EmptyString] DOMString qualifiedName, <span>DocumentType</span> doctype);<!--
  DOMObject getFeature(DOMString feature, DOMString version);-->
  <span>Document</span> <span title=dom-DOMImplementation-createHTMLDocument>createHTMLDocument</span>(DOMString title);
};</pre>

<dl class=domintro>
 <dt><var>hasSupport</var> = <var title=dom-Window-document
 data-anolis-spec=window>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-hasFeature>hasFeature</code>(
 <var>feature</var>, <var>version</var> )

 <dd>
  <p>Returns whether the user agent supports the version <var
  title>version</var> of <var>feature</var>. The empty string means any
  version.
</dl>

<div class=impl>

<p>The <dfn title=dom-DOMImplementation-hasFeature><code>hasFeature(<var
title>feature</var>, <var>version</var>)</code></dfn> method must return
true if the user agent <span title=concept-support-DOMfeatureversion>supports</span>
the (<var>feature</var>, <var>version</var>) tuple and false
otherwise.

</div>

<hr>

<dl class=domintro>
 <dt><var>doctype</var> = <var title=dom-Window-document
 data-anolis-spec=window>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-createDocumentType>createDocumentType</code>(
 <var>qualifiedName</var>, <var>publicId</var>, <var
 title>systemId</var> )

 <dd>
  <p>Returns a new <code>DocumentType</code>, with the given <var
  title>qualifiedName</var>, <var>publicId</var>, and <var
  title>systemId</var>. If <var
  title>qualifiedName</var> doesn't match the <code
  data-anolis-spec=xml>Name</code> production in XML, an <code
  title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
  exception is raised, and if it doesn't match the <code
  data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, a <code
  title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception is raised.


 <dt><var>doc</var> = <var title=dom-Window-document
 data-anolis-spec=window>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-createDocument>createDocument</code>( <var
 title>namespaceURI</var>, <var>qualifiedName</var>, <var
 title>doctype</var> )

 <dd>
  <p>Returns a new <code>Document</code>, with a new root
  <code>Element</code> whose <code title=dom-Node-localName>localName</code> is
  <var>qualifiedName</var> and whose <code
  title=dom-Node-namespaceURI>namespaceURI</code> is <var
  title>namespaceURI</var> (unless <var>qualifiedName</var> is the empty
  string), and with <var>doctype</var>, if it is given, as its <span
  title=concept-doctype>doctype</span>.

  <p>This method raises the same exceptions as the <code
  title=dom-Document-createElementNS>createElementNS</code> method, when called
  with the same arguments. If <var>doctype</var> comes from another
  <code>Document</code>, a <code
  title=dom-DOMException-WRONG_DOCUMENT_ERR>WRONG_DOCUMENT_ERR</code> exception
  is raised.


 <dt><var>doc</var> = <var title=dom-Window-document
 data-anolis-spec=window>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-createHTMLDocument>createHTMLDocument</code>(
 <var>title</var> )

 <dd>
  <p>Returns a new <code>Document</code>, with a basic DOM already
  constructed with an appropriate <code title>title</code> element.
</dl>

<div class=impl>

<p>The <dfn title=dom-DOMImplementation-createDocumentType><code>createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>If <var>qualifiedName</var> doesn't match the <code
 data-anolis-spec=xml>Name</code> production in XML, raise an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and abort these steps.
 <li><p>If <var>qualifiedName</var> doesn't match the <code
 data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, raise a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and
 abort these steps.
 <!--<li><p>If <var>publicId</var> contains a character that doesn't match the <code data-anolis-spec=xml>PubidChar</code> production in XML, raise an <code title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and abort these steps. --> <!-- DOM3 didn't check this -->
 <!--<li><p>If <var>systemId</var> contains both a U+0022 QUOTATION MARK ('"') and a U+0027 APOSTROPHE ("'") character, raise an <code title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and abort these steps.--> <!-- DOM3 didn't check this -->
 <li><p>Return a new <span title=concept-doctype>document type
 declaration</span>, with <var>qualifiedName</var> as its <span
 title=concept-doctype-name>name</span>, <var>publicId</var> as its <span
 title=concept-doctype-publicid>public ID</span>, and <var>systemId</var>
 as its <span title=concept-doctype-systemid>system ID</span>, and with its
 <code title=dom-Node-ownerDocument>ownerDocument</code> set to null.
</ol>
<p class=note>No check is performed that the <var>publicId</var> matches the <code title>PublicChar</code> production in XML or that the <var>systemId</var> doesn't contain both a quotation mark (") and an apostrophe (').

<p>The <dfn title=dom-DOMImplementation-createDocument><code>createDocument(<var>namespaceURI</var>, <var>qualifiedName</var>, <var>doctype</var>)</code></dfn> method must run the following steps:

<p class=XXX>make arguments optional?

<ol>
 <li><p>Let <var>document</var> be a new <code>Document</code> node.
 <li><p>Let <var>element</var> be null.
 <li><p>If <var>qualifiedName</var> is not the empty string, set <var>element</var> to the result of invoking the <code title=dom-Document-createElementNS>createElementNS</code> method with the arguments <var>namespaceURI</var> and <var>qualifiedName</var> on <var>document</var>. If that raised an exception, re-raise the same exception and abort these steps.
 <li>
  <p>If <var>doctype</var> is not null, run the following substeps:
  <ol>
   <li><p>If the <var>doctype</var>'s <code title=dom-Node-ownerDocument>ownerDocument</code> is not null, raise a <code title=dom-DOMException-WRONG_DOCUMENT_ERR>WRONG_DOCUMENT_ERR</code> exception and abort the overall set of steps.
   <li><p>Set the <var>doctype</var>'s <code title=dom-Node-ownerDocument>ownerDocument</code> to <var>document</var>.
   <li><p>Append <var>doctype</var> to <var>document</var>.
  </ol>
 <li><p>If <var>element</var> is not null, append <var>element</var> to <var>document</var>.
 <li><p>Return <var>document</var>.
</ol>

<p>The <dfn
title=dom-DOMImplementation-createHTMLDocument><code>createHTMLDocument(<var
title>title</var>)</code></dfn> method, when invoked, must run the following
steps:

<ol>
 <li><p>Let <var>doc</var> be a newly created <code>Document</code>
 object.

 <li><p>Mark <var>doc</var> as being an <span>HTML document</span>.

 <li><p>Create a new <span title=concept-doctype>document type
 declaration</span>, with "<code title>html</code>" as its <span
 title=concept-doctype-name>name</span> and with its <code
 title=dom-Node-ownerDocument>ownerDocument</code> set to doc. Append the newly
 created node to <var>doc</var>.

 <li><p>Create an <code title>html</code> element in the <span>HTML
 namespace</span>, and append it to <var>doc</var>.

 <li><p>Create a <code title>head</code> element in the <span>HTML
 namespace</span>, and append it to the <code title>html</code> element created
 in the previous step.

 <li><p>Create a <code title>title</code> element in the <span>HTML
 namespace</span>, and append it to the <code title>head</code> element created
 in the previous step.

 <li><p>Create a <code>Text</code> node, and set its <code
 title=dom-CharacterData-data>data</code> attribute to the string given by the
 method's argument (which could be the empty string). Append it to the
 <code title>title</code> element created in the previous step.

 <li><p>Create a <code title>body</code> element in the <span>HTML
 namespace</span>, and append it to the <code title>html</code> element created
 in the earlier step.

 <li><p>Return <var>doc</var>.</p></li>
</ol>

</div>


<h3>Interface <code>Attr</code></h3>

<p class="XXX">Free <code>Attr</code> from <code>Node</code>?</p>

<pre class=idl>interface <dfn>Attr</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-Attr-name>name</span>;
  readonly attribute boolean <span title=dom-Attr-specified>specified</span>;
           attribute DOMString <span title=dom-Attr-value>value</span>;
  readonly attribute <span>Element</span> <span title=dom-Attr-ownerElement>ownerElement</span>;<!--
  readonly attribute TypeInfo schemaTypeInfo;
  readonly attribute boolean isId;-->
};</pre>

<p><code>Attr</code> nodes represent <dfn
title=concept-attribute>attributes</dfn>. They have a <dfn
title=concept-attribute-name>name</dfn> and an <dfn
title=concept-attribute-element>element</dfn> associated with them when they are
created<!--, or when they are passed as the argument to the <code
title=dom-Element-setAttributeNode>setAttributeNode</code> method.
[createAttribute]-->. <code>Attr</code> nodes are not considered part of the
document tree, so their <code title=dom-Node-parentNode>parentNode</code>, <code
title=dom-Node-previousSibling>previousSibling</code> and <code
title=dom-Node-nextSibling>nextSibling</code> attributes return null. Also, its
child nodes can not be manipulated directly through the <code
title=dom-Node-insertBefore>insertBefore</code>, <code
title=dom-Node-replaceChild>replaceChild</code> and <code
title=dom-Node-appendChild>appendChild</code> methods.

<p>The <dfn title=dom-Attr-name><code>name</code></dfn> attribute must return
the <span title=concept-attribute-name>name</span> associated with the
<span>context node</span>.

<p>The <dfn title=dom-Attr-specified><code>specified</code></dfn> attribute must
return true.

<p>The <dfn title=dom-Attr-value><code>value</code></dfn> attribute, on getting,
must return the same value as the <code
title=dom-Node-textContent>textContent</code> IDL attribute on the
<span>context node</span>, and on setting, must act as if the <code
title=dom-Node-textContent>textContent</code> IDL attribute on the
<span>context node</span> had been set to the new value.

<p>The <dfn title=dom-Attr-ownerElement><code>ownerElement</code></dfn>
attribute must return the <span title=concept-attribute-element>element</span>
associated with the <span>context node</span><!--, if there is one, or null
otherwise [createAttribute]-->.

<hr>

<p>This specification further defines two special types of <span
title=concept-attribute>attributes</span>: <span title=concept-ID-attribute>ID
attributes</span> and <span title=concept-class-attribute>class
attributes</span>.

<p><dfn title=concept-ID-attribute>ID attributes</dfn> must have a
<code title=dom-Attr-value>value</code> that contains at least one character and
does not contain any <span title="space character">space characters</span>. The
<code title=dom-Attr-value>value</code> must be unique amongst all the <span
title=concept-id>IDs</span> in the element's <span>home subtree</span>.

<p class=note>For example, the <code title=attr-id
data-anolis-spec=html>id</code> attribute in HTML is an <span
title=concept-ID-attribute>ID attribute</span>, as well as the <code
title>id</code> attributes in MathML and SVG. <span data-anolis-ref
class=informative>HTML</span> <span data-anolis-ref
class=informative>MATHML</span> <span data-anolis-ref
class=informative>SVG</span>

<p><dfn title=concept-class-attribute>Class attributes</dfn> must have a
<code title=dom-Attr-value>value</code> that is a <span>set of space-separated
tokens</span> representing the various <dfn title=concept-class>classes</dfn>
that the element belongs to.

<p>The <span title=concept-class>classes</span> that an <code>Element</code>
node has associated with it is the set of all the <span
title=concept-class>classes</span> returned when the value of the <span
title=concept-class-attribute>class attribute</span> is <span
title="split a string on spaces">split on spaces</span>. (Duplicates are
ignored.)

<p class=note>The <code title>class</code> attributes in HTML, MathML and SVG
are all <span title=concept-class-attribute>class attributes</span>. <span
data-anolis-ref class=informative>HTML</span> <span data-anolis-ref
class=informative>MATHML</span> <span data-anolis-ref
class=informative>SVG</span>

<p class=note>This specification does not <!--normatively--> define the <span
title=concept-attribute-name>name</span> of <span
title=concept-id-attribute>ID</span> or <span
title=concept-class-attribute>class attributes</span>.


<h3>Interface <code>Element</code></h3>
<pre class=idl>interface <dfn>Element</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-Element-tagName>tagName</span>;

  DOMString? <span title=dom-Element-getAttribute>getAttribute</span>(DOMString name);
  DOMString? <span title=dom-Element-getAttributeNS>getAttributeNS</span>(DOMString namespaceURI, DOMString localName);
  void <span title=dom-Element-setAttribute>setAttribute</span>(DOMString name, DOMString value);
  void <span title=dom-Element-setAttributeNS>setAttributeNS</span>(DOMString namespaceURI, DOMString qualifiedName, DOMString value);
  void <span title=dom-Element-removeAttribute>removeAttribute</span>(DOMString name);
  void <span title=dom-Element-removeAttributeNS>removeAttributeNS</span>(DOMString namespaceURI, DOMString localName);
  boolean <span title=dom-Element-hasAttribute>hasAttribute</span>(DOMString <var>qualifiedName</var>);
  boolean <span title=dom-Element-hasAttributeNS>hasAttributeNS</span>(DOMString <var>namespaceURI</var>, DOMString <var>localName</var>);
<!--
  <span>Attr</span> <span title=dom-Element-getAttributeNode>getAttributeNode</span>(DOMString name);
  <span>Attr</span> <span title=dom-Element-getAttributeNodeNS>getAttributeNodeNS</span>(DOMString namespaceURI, DOMString localName);
  <span>Attr</span> <span title=dom-Element-setAttributeNode>setAttributeNode</span>(Attr newAttr);
  <span>Attr</span> <span title=dom-Element-removeAttributeNode>removeAttributeNode</span>(Attr oldAttr);
-->
  <span>NodeList</span> <span title=dom-Element-getElementsByTagName>getElementsByTagName</span>(DOMString <var>qualifiedName</var>);
  <span>NodeList</span> <span title=dom-Element-getElementsByTagNameNS>getElementsByTagNameNS</span>(DOMString <var>namespaceURI</var>, DOMString <var>localName</var>);
  <span>NodeList</span> <span title=dom-Element-getElementsByClassName>getElementsByClassName</span>(DOMString <var>classNames</var>);<!--
  readonly attribute TypeInfo schemaTypeInfo;
  void setIdAttribute(DOMString name, boolean isId);
  void setIdAttributeNS(DOMString namespaceURI, DOMString localName, boolean isId);
  void setIdAttributeNode(Attr idAttr, boolean isId);-->

           attribute <span>HTMLCollection</span> <span title=dom-Element-children>children</span>;
};</pre>

<p><code>Element</code> nodes can have a <dfn title=concept-id>unique
identifier (ID)</dfn> associated with them. User agents must associate the
<code title=dom-Attr-value>value</code> of all <span
title=concept-ID-attribute>ID attributes</span> in the <code>Element</code>
node's <code title=dom-Node-attributes>attributes</code> with the
<code>Element</code> node, unless it is the empty string.

<p>Specifications may define <dfn>base URL change steps</dfn>.

<p>When an <code>Element</code> node is <dfn>affected by a base URL
change</dfn>, the user agent must run the <span>base URL change steps</span>, as
defined in <span>other applicable specifications</span>.

<p>The <dfn title=dom-Element-tagName><code>tagName</code></dfn> attribute must,
on getting, run the following steps:
<ol>
 <li><p>If the <span>context node</span>'s <code
 title=dom-Node-prefix>prefix</code> is not null, let <var>tagName</var>
 be the concatenation of the <span>context node</span>'s <code
 title=dom-Node-prefix>prefix</code>, a U+003E COLON (":") character and its
 <code title=dom-Node-localName>localName</code>. Otherwise, let <var
 title>tagName</var> be just the the <span>context node</span>'s <code
 title=dom-Node-localName>localName</code>.

 <li><p>If the <span>context node</span> is in the <span>HTML namespace</span>
 and its <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, return <var>tagName</var>, <span>converted to
 uppercase</span>. Otherwise, return <var>tagName</var>.
</ol>

<hr>

<p>The <dfn title=dom-Element-getAttribute><code>getAttribute(<var>name</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>If the <span>context node</span> is in the
 <span>HTML namespace</span> and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var>name</var> be <var>name</var>,
 <span>converted to lowercase</span>.

 <li><p>Return the value of the first attribute in the
 <span>context node</span>'s
 <code title=dom-Node-attributes>attributes</code> whose
 <span title=concept-attribute-name>name</span> is <var>name</var>, if
 the attribute is present, or null otherwise.
</ol>

<p>The <dfn title=dom-Element-getAttributeNS>getAttributeNS(<var>namespaceURI</var>, <var>localName</var></dfn> method must return the value of the attribute in
the <span>context node</span>'s <code title=dom-Node-attributes>attributes</code> whose <code title=dom-Node-namespaceURI>namespaceURI</code> is <var>namespaceURI</var> and <code title=dom-Node-localName>localName</code> is <var>localName</var>, if the attribute is present, or null otherwise.</p>

<p>The <dfn title=dom-Element-setAttribute><code>setAttribute(<var>name</var>, <var>value</var>)</code></dfn> method must run the
following steps:

<ol>
 <li><p>If <var>name</var> is empty or <var>name</var> doesn't
 match the <code data-anolis-spec=xml>Name</code> production in XML, raise an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and abort these steps.

 <li class=XXX><p>Do something about <var>name</var> == "xmlns"?
 <a href=https://bugzilla.mozilla.org/show_bug.cgi?id=315805>Moz bug 315805</a>

 <li><p>If the <span>context node</span> is in the <span>HTML namespace</span>
 and its <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var>name</var> be <var>name</var>,
 <span>converted to lowercase</span>.

 <li><p>If the node doesn't have an attribute whose <span
 title=concept-attribute-name>name</span> <span
 title=case-sensitive>case-sensitively</span> equals <var>name</var>,
 create an <code>Attr</code> node, with <var>name</var> as its <span
 title=concept-attribute-name>name</span> and the <span>context node</span> as
 its <span title=concept-attribute-element>element</span>. Set its <code
 title=dom-Attr-value>value</code> to <var>value</var>. Append this node
 to the <span title="context node">context node's</span> <code
 title=dom-Node-attributes>attributes</code>, as its last item.

 <li><p>Otherwise, set the <code title=dom-Attr-value>value</code> of the first
 attribute in the <span title="context node">context node's</span> <code
 title=dom-Node-attributes>attributes</code> whose <span
 title=concept-attribute-name>name</span> <span
 title=case-sensitive>case-sensitively</span> equals <var>name</var>,
 in any namespace, to <var>value</var>.
</ol>

<p class=XXX><dfn title=dom-Element-setAttributeNS>setAttributeNS</dfn>

<p class=XXX><dfn title=dom-Element-removeAttribute>removeAttribute</dfn>

<p class=XXX><dfn title=dom-Element-removeAttributeNS>removeAttributeNS</dfn>

<p>The
<dfn title=dom-Element-hasAttribute><code>hasAttribute(<var>qualifiedName</var>)</code></dfn>
method must run these steps:</p>
<ol>
 <li><p>If the <span>context node</span> is in the
 <span>HTML namespace</span> and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var>qualifiedName</var> be
 <span>converted to lowercase</span>.

 <li><p>Return true if <span>context node</span>'s
 <code title=dom-Node-attributes>attributes</code> contains an attribute
 whose <span title=concept-attribute-name>name</span> is
 <var>qualifiedName</var>, or false otherwise.
</ol>

<p>The
<dfn title=dom-Element-hasAttributeNS><code>hasAttributeNS(<var>namespaceURI</var>, <var>localName</var>)</code></dfn>
method must return true if <span>context node</span>'s
<code title=dom-Node-attributes>attributes</code> contains an attribute
whose <code title=dom-Node-namespaceURI>namespaceURI</code> is
<var>namespaceURI</var> and <code title=dom-Node-localName>localName</code>
is <var>localName</var>, or false otherwise.</p>

<!--<dfn title=dom-Element-getAttributeNode>getAttributeNode</dfn>: when the
Element.getAttributeNode() method is invoked on an HTML element, the name
argument must be converted to ASCII lowercase before the element's attributes
are examined. (In HTML documents.) -->

<!-- <dfn title=dom-Element-setAttributeNode>setAttributeNode</dfn>: when an
Attr node is set on an HTML element using Element.setAttributeNode(), it must
have its name converted to ASCII lowercase before the element is affected.
(In HTML documents.) -->

<hr>

<p>The <dfn
title=dom-Element-getElementsByTagName><code>getElementsByTagName(<var
title>name</var>)</code></dfn> method on the <code>Element</code>
interface must return a <span title=concept-collection-live>live</span>
<code>NodeList</code> with the nodes that the <code
title=dom-Document-getElementsByTagName>getElementsByTagName</code>
method would return when called on the <span title="context node">context
node's</span> <code title=dom-Node-ownerDocument>ownerDocument</code> and
passed the same argument, excluding any elements that are not descendants of
the <span>context node</span> on which the method was invoked.
<p>A new <code>NodeList</code> object must be returned each time.


<p>The <dfn
title=dom-Element-getElementsByTagNameNS><code>getElementsByTagNameNS(<var
title>namespaceURI</var>, <var>localName</var>)</code></dfn> method on the
<code>Element</code> interface must return a <span
title=concept-collection-live>live</span> <code>NodeList</code> with the nodes
that the <code
title=dom-Document-getElementsByTagNameNS>getElementsByTagNameNS</code>
method would return when called on the <span title="context node">context
node's</span> <code title=dom-Node-ownerDocument>ownerDocument</code> and
passed the same arguments, excluding any elements that are not descendants of
the <span>context node</span> on which the method was invoked.
<p>A new <code>NodeList</code> object must be returned each time.


<p>The <dfn
title=dom-Element-getElementsByClassName><code>getElementsByClassName(<var
title>classNames</var>)</code></dfn> method on the <code>Element</code>
interface must return a <span title=concept-collection-live>live</span>
<code>NodeList</code> with the nodes that the <code
title="dom-Document-getElementsByClassName">getElementsByClassName</code>
method would return when called on the <span title="context node">context
node's</span> <code title=dom-Node-ownerDocument>ownerDocument</code> and
passed the same argument, excluding any elements that are not descendants of
the <span>context node</span> on which the method was invoked.
<p>A new <code>NodeList</code> object must be returned each time.

<hr>

<p>The <dfn title=dom-Element-children><code>children</code></dfn> attribute
must return an <code>HTMLCollection</code> <span
title=concept-collection>collection</span>, rooted at the <span>context
node</span>, whose filter matches only <code>Element</code> nodes whose <code
title=dom-Node-parentNode>parentNode</code> is the <span>context node</span>.
<span class=XXX title>Or a <code>NodeList</code>?</span>


<h3>Interface <code>DocumentType</code></h3>
<pre class=idl>interface <dfn>DocumentType</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-DocumentType-name>name</span>;<!--
  readonly attribute NamedNodeMap entities;
  readonly attribute NamedNodeMap notations;-->
  readonly attribute DOMString <span title=dom-DocumentType-publicId>publicId</span>;
  readonly attribute DOMString <span title=dom-DocumentType-systemId>systemId</span>;<!--
  readonly attribute DOMString internalSubset;-->
};</pre>

<p><code>DocumentType</code> nodes represent <dfn title=concept-doctype>document
type declarations</dfn>. They have a <dfn title=concept-doctype-name>name</dfn>
and potentially a <dfn title=concept-doctype-publicid>public ID</dfn>, and a
<dfn title=concept-doctype-systemid>system ID</dfn> associated with them when
they are created.

<p>The <dfn title=dom-DocumentType-name><code>name</code></dfn> attribute must,
on getting, return the <span title="context node">context node's</span> <span
title=concept-doctype-name>name</span>.

<p>The <dfn title=dom-DocumentType-publicId><code>publicId</code></dfn>
attribute must, on getting, return the <span title="context node">context
node's</span> <span title=concept-doctype-publicid>public ID</span>, if it has
one, or the empty string otherwise.

<p>The <dfn title=dom-DocumentType-systemId><code>systemId</code></dfn>
attribute must, on getting, return the <span title="context node">context
node's</span> <span title=concept-doctype-systemid>system ID</span>, if it has
one, or the empty string otherwise.


<h3>Interface <code>ProcessingInstruction</code></h3>
<pre class=idl>interface <dfn>ProcessingInstruction</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-ProcessingInstruction-target>target</span>;
           attribute DOMString <span title=dom-ProcessingInstruction-data>data</span>;
};</pre>

<p><code>ProcessingInstruction</code> nodes represent <dfn
title=concept-PI>processing instructions</dfn>. They have a <dfn
title=concept-PI-target>target</dfn> associated with them when they are created,
as well as some <dfn title=concept-PI-data>data</dfn>.

<p>The <dfn title=dom-ProcessingInstruction-target><code>target</code></dfn>
attribute must, on getting, return the <span title="context node">context
node's</span> <span title=concept-PI-target>target</span>.

<p>The <dfn title=dom-ProcessingInstruction-data><code>data</code></dfn>
attribute must, on getting, return the <span title="context node">context
node's</span> <span title=concept-PI-data>data</span>, and on setting, set the
<span title="context node">context node's</span> <span
title=concept-PI-data>data</span> to the new value.


<h3>Interface <code>CharacterData</code></h3>
<pre class=idl>interface <dfn>CharacterData</dfn> : <span>Node</span> {
  [TreatNullAs=EmptyString] attribute DOMString <span title=dom-CharacterData-data>data</span>;
  readonly attribute unsigned long <span title=dom-CharacterData-length>length</span>;
  DOMString <span title=dom-CharacterData-substringData>substringData</span>(unsigned long <var>offset</var>, unsigned long <var>count</var>);
  void <span title=dom-CharacterData-appendData>appendData</span>(DOMString <var>data</var>);
  void <span title=dom-CharacterData-insertData>insertData</span>(unsigned long <var>offset</var>, DOMString <var>data</var>);
  void <span title=dom-CharacterData-deleteData>deleteData</span>(unsigned long <var>offset</var>, unsigned long <var>count</var>);
  void <span title=dom-CharacterData-replaceData>replaceData</span>(unsigned long <var>offset</var>, unsigned long <var>count</var>, DOMString <var>data</var>);
};</pre>

<p>The <dfn title=dom-CharacterData-data><code>data</code></dfn> attribute must return the data of the node, and on setting, must change the node's data to the new value.

<p>The <dfn title=dom-CharacterData-length><code>length</code></dfn> attribute must return the number of UTF-16 code units represented by the node's data.

<p>The <dfn title=dom-CharacterData-substringData><code>substringData(<var
title>offset</var>, <var>count</var>)</code></dfn> method must run these
steps:

<ol>
 <li><p>If <var>offset</var> is negative or is greater than the
 <span>context node</span>'s <code title=dom-CharacterData-length>length</code>,
 or if <var>count</var> is negative, raise an <code
 title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code> exception and abort
 these steps.

 <li><p>If <span title><var>offset</var>+<var>count</var></span> is
 greater than the <span>context node</span>'s <code
 title=dom-CharacterData-length>length</code>, return a <code
 data-anolis-spec=webidl>DOMString</code> whose value is the UTF-16 code units
 from the <var>offset</var>th UTF-16 code unit to the end of <var
 title>data</var>.

 <li><p>Return a <code data-anolis-spec=webidl>DOMString</code> whose value is
 the UTF-16 code units from the <var>offset</var>th UTF-16 code unit to
 the <span title><var>offset</var>+<var>count</var></span>th UTF-16
 code unit in <var>data</var>.
</ol>

<p>The <dfn title=dom-CharacterData-appendData><code>appendData(<var>data</var>)</code></dfn> method must append <var>data</var> to the <span>context node</span>'s data.</p>

<p>The <dfn title=dom-CharacterData-insertData><code>insertData(<var>offset</var>, <var>data</var>)</code></dfn> method must run these steps:</p>

<ol>
 <li><p>If <var>offset</var> is greater than the <span>context node</span>'s
 <code title=dom-CharacterData-length>length</code>, raise an
 <code title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code> exception
 and terminate these steps.</p></li>

 <li><p>Insert <var>data</var> into the <span>context node</span>'s data
 after <var>offset</var> UTF-16 code units.</p></li>
</ol>

<p>The <dfn title=dom-CharacterData-deleteData><code>deleteData(<var>offset</var>, <var>count</var>)</code></dfn> method must run these steps:</p>

<ol>
 <li><p>If <var>offset</var> is greater than the <span>context node</span>'s
 <code title=dom-CharacterData-length>length</code>, raise an
 <code title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code> exception
 and terminate these steps.</p></li>

 <li><p>If <var>offset</var>+<var>count</var> is greater than the
 <span>context node</span>'s
 <code title=dom-CharacterData-length>length</code> let <var>count</var> be
 <code title=dom-CharacterData-length>length</code>-<var>offset</var>.</p></li>

 <li><p>Starting from <var>offset</var> UTF-16 code units remove
 <var>count</var> UTF-16 code units from the <span>context node</span>'s
 data.</p></li>
</ol>

<p>The <dfn title=dom-CharacterData-replaceData><code>replaceData(<var>offset</var>, <var>count</var>, <var>data</var>)</code></dfn> method must act as if
the <code title=dom-CharacterData-deleteData>deleteData()</code> method is
invoked with <var>offset</var> and <var>count</var> as arguments followed
by the <code title=dom-CharacterData-insertData>insertData()</code> method
with <var>offset</var> and <var>data</var> as arguments and re-raise any
exceptions these methods might have raised.</p>


<h3>Interface <code>Text</code></h3>
<pre class=idl>interface <dfn>Text</dfn> : <span>CharacterData</span> {
  <span>Text</span> <span title=dom-Text-splitText>splitText</span>(unsigned long offset);<!--
  readonly attribute boolean isElementContentWhitespace;-->
  readonly attribute DOMString <span title=dom-Text-wholeText>wholeText</span>;
  <span>Text</span> <span title=dom-Text-replaceWholeText>replaceWholeText</span>(DOMString content);
};</pre>

<p class=XXX><dfn title=dom-Text-splitText>splitText</dfn>

<p class=XXX><dfn title=dom-Text-wholeText>wholeText</dfn>

<p class=XXX><dfn title=dom-Text-replaceWholeText>replaceWholeText</dfn>

<!-- isElementContentWhitespace: Mozilla returns true if the node contains only
space, tab, newline -->


<h3>Interface <code>Comment</code></h3>
<pre class=idl>interface <dfn>Comment</dfn> : <span>CharacterData</span> {
};</pre>



<h2>Collections</h2>
<p>A <dfn title=concept-collection>collection</dfn> is an object that represents
a lists of DOM nodes. A <span title=concept-collection>collection</span> can be
either <dfn title=concept-collection-live>live</dfn> or <dfn
title=concept-collection-static>static</dfn>. Unless otherwise stated, a <span
title=concept-collection>collection</span> must be <span
title=concept-collection-live>live</span>.

<p>If a <span title=concept-collection>collection</span> is <span
title=concept-collection-live>live</span>, then the attributes and methods on
that object must</span> operate on the actual underlying data, not a snapshot of
the data.

<p>When a <span title=concept-collection>collection</span> is created, a filter
and a root are associated with it.

<p>The <span title=concept-collection>collection</span> then <dfn
title="represented by the collection">represents</dfn> a view of the subtree
rooted at the <span title=concept-collection>collection's</span> root,
containing only nodes that match the given filter. The view is linear. In the
absence of specific requirements to the contrary, the nodes within the <span
title=concept-collection>collection</span> must be sorted in <span>tree
order</span>.

<p>An attribute that returns a <span title=concept-collection-live>live</span>
<span title=concept-collection>collection</span> must return the same object
every time it is retrieved.


<h3>Interface <code>NodeList</code></h3>
<p>A <code>NodeList</code> object is a kind of <span
title=concept-collection>collection</span>.

<pre class=idl>interface <dfn>NodeList</dfn> {
  getter <span>Node</span> <span title=dom-NodeList-item>item</span>(unsigned long index);
  readonly attribute unsigned long <span title=dom-NodeList-length>length</span>;
};</pre>

<p>The <dfn title=dom-NodeList-item><code>item(<var
title>index</var>)</code></dfn> method must return the <var>index</var>th
node in the <span title=concept-collection>collection</span>. If there is no
<var>index</var>th node in the <span
title=concept-collection>collection</span>, then the method must return null.

<p>The <dfn title=dom-NodeList-length><code>length</code></dfn> attribute must,
on getting, return the number of nodes <span>represented by the
collection</span>.

<p><code>NodeList</code>s are enumerable. <span class=XXX title>Explain? <code
title>for ... in</code></span>


<h3>Interface <code>HTMLCollection</code></h3>
<p>The <code>HTMLCollection</code> interface represents a generic <span
title=concept-collection>collection</span> of elements.

<p class=note>This interface is called <code>HTMLCollection</code> for
historical reasons. The various getters on this interface return <code
data-anolis-spec=webidl>object</code> for interfaces that inherit from
it, which return other objects for historical reasons.

<pre class=idl>interface <dfn>HTMLCollection</dfn> {
readonly attribute unsigned long <span title=dom-HTMLCollection-length>length</span>;
caller getter object <span title=dom-HTMLCollection-item>item</span>(unsigned long index); // only returns Element
caller getter object <span title=dom-HTMLCollection-namedItem>namedItem</span>(DOMString name); // only returns Element
};</pre>

<dl class=domintro>
 <dt><var>collection</var> . <code title=dom-HTMLCollection-length>length</code>
 <dd>
  <p>Returns the number of elements in the collection.

 <dt><var>element</var> = <var>collection</var> . <code title=dom-HTMLCollection-item>item</code>(<var>index</var>)
 <dt><var>collection</var>[<var>index</var>]
 <dt><var>collection</var>(<var>index</var>)
 <dd>
  <p>Returns the item with index <var>index</var> from the collection. The items are sorted in <span>tree order</span>.
  <p>Returns null if <var>index</var> is out of range.

 <dt><var>element</var> = <var>collection</var> . <code title=dom-HTMLCollection-namedItem>namedItem</code>(<var>name</var>)</dt>
 <dt><var>collection</var>[<var>name</var>]</dt>
 <dt><var>collection</var>(<var>name</var>)</dt>
 <dd>
  <p>Returns the first item with <span title="concept-id">ID</span> or name <var>name</var>
  from the collection.</p>
  <p>Returns null if no element with that <span title="concept-id">ID</span> or name could be found.</p>
  <p>Only <code title>a</code>, <code title>applet</code title>, <code title>area</code>,
  <code title>embed</code>, <code title>form</code>, <code title>frame</code>,
  <code title>frameset</code>, <code title>iframe</code>, <code title>img</code>, and
  <code title>object</code> elements in the <span>HTML namespace</span> can have a
  name for the purpose of this method; their name is given by the value of their
  <code title>name</code> attribute.</p>
 </dd>
</dl>

<p>The object's <span data-anolis-spec=webidl>supported property indices</span>
are the numbers in the range zero to one less than the number of nodes
<span>represented by the collection</span>. If there are no such elements, then
there are no <span data-anolis-spec=webidl>supported property indices</span>.

<p>The <dfn title=dom-HTMLCollection-length><code>length</code></dfn> attribute
must return the number of nodes <span>represented by the collection</span>.

<p>The <dfn title=dom-HTMLCollection-item><code>item(<var
title>index</var>)</code></dfn> method must return the <var
title>index</var>th node in the collection. If there is no <var
title>index</var>th node in the collection, then the method must
return null.

<p>The <span data-anolis-spec=webidl>supported property names</span> consist
of the values of the <code title>name</code> attributes of each <code
title>a</code>, <code title>applet</code>, <code title>area</code>, <code
title>embed</code>, <code title>form</code>, <code title>frame</code>, <code
title>frameset</code>, <code title>iframe</code>, <code title>img</code>, and
<code title>object</code> element in the <span>HTML namespace</span>,
<span>represented by the collection</span> with a <code title>name</code>
attribute, plus the list of <span title=concept-id>IDs</span> that the elements
<span>represented by the collection</span> have.

<p>The <dfn title=dom-HTMLCollection-namedItem><code>namedItem(<var
title>key</var>)</code></dfn> method must return the first node in the
<span title=concept-collection>collection</span> that matches the following
requirements:</p>

<ul>
 <li>It is an <code title>a</code>, <code title>applet</code>, <code
 title>area</code>, <code title>embed</code>, <code title>form</code>, <code
 title>frame</code>, <code title>frameset</code>, <code title>iframe</code>,
 <code title>img</code>, or <code title>object</code> element, in the <span>HTML
 namespace</span>, with a <code title>name</code> attribute equal to <var
 title>key</var>, or,

 <li>It is an element with an <span title=concept-id>ID</span>
 equal to <var>key</var>.
</ul>

<p>If no such elements are found, then the method must return
null.


<h3>Interface <code>NamedNodeMap</code></h3>
<p>A <code>NamedNodeMap</code> object is a kind of <span
title=concept-collection>collection</span>, whose primary purpose is to expose
<code>Node</code>s by name.

<pre class=idl>interface <dfn>NamedNodeMap</dfn> {
  <span>Node</span> <span title=dom-NamedNodeMap-getNamedItem>getNamedItem</span>(DOMString name);
  <span>Node</span> <span title=dom-NamedNodeMap-setNamedItem>setNamedItem</span>(<span>Node</span> arg);
  <span>Node</span> <span title=dom-NamedNodeMap-removeNamedItem>removeNamedItem</span>(DOMString name);
  <span>Node</span> <span title=dom-NamedNodeMap-item>item</span>(unsigned long index);
  readonly attribute unsigned long <span title=dom-NamedNodeMap-length>length</span>;
  <span>Node</span> <span title=dom-NamedNodeMap-getNamedItemNS>getNamedItemNS</span>(DOMString namespaceURI, DOMString localName);
  <span>Node</span> <span title=dom-NamedNodeMap-setNamedItemNS>setNamedItemNS</span>(<span>Node</span> arg);
  <span>Node</span> <span title=dom-NamedNodeMap-removeNamedItemNS>removeNamedItemNS</span>(DOMString namespaceURI, DOMString localName);
};</pre>

<p class=XXX><dfn title=dom-NamedNodeMap-getNamedItem>getNamedItem</dfn>

<p class=XXX><dfn title=dom-NamedNodeMap-setNamedItem>setNamedItem</dfn>

<p class=XXX><dfn title=dom-NamedNodeMap-removeNamedItem>removeNamedItem</dfn>

<p class=XXX><dfn title=dom-NamedNodeMap-item>item</dfn>

<p>The <dfn title=dom-NamedNodeMap-length><code>length</code></dfn> attribute
must, on getting, return the number of nodes <span>represented by the
collection</span>.

<p class=XXX><dfn title=dom-NamedNodeMap-getNamedItemNS>getNamedItemNS</dfn>

<p class=XXX><dfn title=dom-NamedNodeMap-setNamedItemNS>setNamedItemNS</dfn>

<p class=XXX><dfn title=dom-NamedNodeMap-removeNamedItemNS>removeNamedItemNS</dfn>



<h2>Lists</h2>
<h3>Interface <code>DOMStringList</code></h3>
<pre class=idl>interface <dfn>DOMStringList</dfn> {
  DOMString <span title=dom-DOMStringList-item>item</span>(unsigned long index);
  readonly attribute unsigned long <span title=dom-DOMStringList-length>length</span>;
  boolean <span title=dom-DOMStringList-contains>contains</span>(DOMString str);
};</pre>

<p class=XXX><dfn title=dom-DOMStringList-item>item</dfn>

<p class=XXX><dfn title=dom-DOMStringList-length>length</dfn>

<p class=XXX><dfn title=dom-DOMStringList-contains>contains</dfn>


<h3>Interface <code>DOMTokenList</code></h3>
<p>The <code>DOMTokenList</code> interface represents an interface
to an underlying string that consists of a <span>set of
space-separated tokens</span>.</p>

<p class="note"><code>DOMTokenList</code> objects are always
<span>case-sensitive</span>, even when the underlying string might
ordinarily be treated in a case-insensitive manner.</p>

<pre class="idl">interface <dfn>DOMTokenList</dfn> {
  readonly attribute unsigned long <span title="dom-DOMTokenList-length">length</span>;
  getter DOMString <span title="dom-DOMTokenList-item">item</span>(unsigned long index);
  boolean <span title="dom-DOMTokenList-contains">contains</span>(DOMString token);
  void <span title="dom-DOMTokenList-add">add</span>(DOMString token);
  void <span title="dom-DOMTokenList-remove">remove</span>(DOMString token);
  boolean <span title="dom-DOMTokenList-toggle">toggle</span>(DOMString token);
  <span title="dom-DOMTokenList-toString">stringifier</span> DOMString ();
};</pre>

<dl class="domintro">

 <dt><var>tokenlist</var> . <code title="dom-DOMTokenList-length">length</code></dt>
 <dd>
  <p>Returns the number of tokens in the string.</p>
 </dd>

 <dt><var>element</var> = <var>tokenlist</var> . <code title="dom-DOMTokenList-item">item</code>(<var>index</var>)</dt>
 <dt><var>tokenlist</var>[<var>index</var>]</dt>
 <dd>
  <p>Returns the token with index <var>index</var>. The tokens are returned in the order they are found in the underlying string.</p>
  <p>Returns null if <var>index</var> is out of range.</p>
 </dd>

 <dt><var>hastoken</var> = <var>tokenlist</var> . <code title="dom-DOMTokenList-contains">contains</code>(<var>token</var>)</dt>
 <dd>
  <p>Returns true if the <var>token</var> is present; false otherwise.</p>
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var>token</var> is empty.</p>
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var>token</var> contains any spaces.</p>
 </dd>

 <dt><var>tokenlist</var> . <code title="dom-DOMTokenList-add">add</code>(<var>token</var>)</dt>
 <dd>
  <p>Adds <var>token</var>, unless it is already present.</p>
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var>token</var> is empty.</p>
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var>token</var> contains any spaces.</p>
 </dd>

 <dt><var>tokenlist</var> . <code title="dom-DOMTokenList-remove">remove</code>(<var>token</var>)</dt>
 <dd>
  <p>Removes <var>token</var> if it is present.</p>
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var>token</var> is empty.</p>
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var>token</var> contains any spaces.</p>
 </dd>

 <dt><var>hastoken</var> = <var>tokenlist</var> . <code title="dom-DOMTokenList-toggle">toggle</code>(<var>token</var>)</dt>
 <dd>
  <p>Adds <var>token</var> if it is not present, or removes
  it if it is. Returns true if <var>token</var> is now
  present (it was added); returns false if it is not (it was
  removed).</p>
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var>token</var> is empty.</p>
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var>token</var> contains any spaces.</p>
 </dd>

</dl>

<div class="impl">

<p>The <dfn title="dom-DOMTokenList-length"><code>length</code></dfn>
attribute must return the number of tokens that result from <span
title="split a string on spaces">splitting the underlying string on
spaces</span>. This is the <var
title="dom-DOMTokenList-length">length</var>.</p>

<p>The object's <span data-anolis-spec=webidl>supported property
indices</span> are the numbers in the range zero to <span title=""><var
title="dom-DOMTokenList-length">length</var>&minus;1</span>, unless the <var
title="dom-DOMTokenList-length">length</var> is zero, in which case there are no
<span data-anolis-spec=webidl>supported property indices</span>.</p>

<p>The <dfn title="dom-DOMTokenList-item"><code>item(<var
title="">index</var>)</code></dfn> method must <span title="split a
string on spaces">split the underlying string on spaces</span>,
preserving the order of the tokens as found in the underlying
string, and then return the <var>index</var>th item in this
list. If <var>index</var> is equal to or greater than the
number of tokens, then the method must return null.</p>

<p class="example">For example, if the string is "<code title="">a b
a c</code>" then there are four tokens: the token with index 0 is
"<code title="">a</code>", the token with index 1 is "<code
title="">b</code>", the token with index 2 is "<code
title="">a</code>", and the token with index 3 is "<code
title="">c</code>".</p>

<p>The <dfn title="dom-DOMTokenList-contains"><code>contains(<var
title="">token</var>)</code></dfn> method must run the following
algorithm:</p>

<ol>

 <li>If the <var>token</var> argument is the empty string,
 then raise a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and stop the
 algorithm.</li>

 <li>If the <var>token</var> argument contains any <span
 title="space character">space characters</span>, then raise an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and stop the
 algorithm.</li>

 <li>Otherwise, <span title="split a string on spaces">split the
 underlying string on spaces</span> to get the list of tokens in the
 object's underlying string.</li>

 <li>If the token indicated by <var>token</var> is a
 <span>case-sensitive</span> match for one of the tokens in the
 object's underlying string then return true and stop this
 algorithm.</li>

 <li>Otherwise, return false.</li>

</ol>

<p>The <dfn title="dom-DOMTokenList-add"><code>add(<var
title="">token</var>)</code></dfn> method must run the following
algorithm:</p>

<ol>

 <li>If the <var>token</var> argument is the empty string,
 then raise a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and stop the
 algorithm.</li>

 <li>If the <var>token</var> argument contains any <span
 title="space character">space characters</span>, then raise an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and stop the
 algorithm.</li>

 <li>Otherwise, <span title="split a string on spaces">split the
 underlying string on spaces</span> to get the list of tokens in the
 object's underlying string.</li>

 <li>If the given <var>token</var> is a
 <span>case-sensitive</span> match for one of the tokens in the
 <code>DOMTokenList</code> object's underlying string then stop the
 algorithm.</li>

 <li>Otherwise, if the <code>DOMTokenList</code> object's underlying
 string is not the empty string and the last character of that
 string is not a <span>space character</span>, then append a U+0020
 SPACE character to the end of that string.</li>

 <li>Append the value of <var>token</var> to the end of the
 <code>DOMTokenList</code> object's underlying string.</li>

</ol>

<p>The <dfn title="dom-DOMTokenList-remove"><code>remove(<var
title="">token</var>)</code></dfn> method must run the following
algorithm:</p>

<ol>

 <li>If the <var>token</var> argument is the empty string,
 then raise a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and stop the
 algorithm.</li>

 <li>If the <var>token</var> argument contains any <span
 title="space character">space characters</span>, then raise an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and stop the
 algorithm.</li>

 <li>Otherwise, <span title="remove a token from a string">remove
 the given <var>token</var> from the underlying
 string</span>.</li>

</ol>

<p>The <dfn title="dom-DOMTokenList-toggle"><code>toggle(<var
title="">token</var>)</code></dfn> method must run the following
algorithm:</p>

<ol>

 <li>If the <var>token</var> argument is the empty string,
 then raise a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and stop the
 algorithm.</li>

 <li>If the <var>token</var> argument contains any <span
 title="space character">space characters</span>, then raise an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception and stop the
 algorithm.</li>

 <li>Otherwise, <span title="split a string on spaces">split the
 underlying string on spaces</span> to get the list of tokens in the
 object's underlying string.</li>

 <li>If the given <var>token</var> is a
 <span>case-sensitive</span> match for one of the tokens in the
 <code>DOMTokenList</code> object's underlying string then <span
 title="remove a token from a string">remove the given <var
 title="">token</var> from the underlying string</span> and stop the
 algorithm, returning false.</li>

 <li>Otherwise, if the <code>DOMTokenList</code> object's underlying
 string is not the empty string and the last character of that
 string is not a <span>space character</span>, then append a U+0020
 SPACE character to the end of that string.</li>

 <li>Append the value of <var>token</var> to the end of the
 <code>DOMTokenList</code> object's underlying string.</li>

 <li>Return true.</li>

</ol>

<p>Objects implementing the <code>DOMTokenList</code> interface must
<dfn title="dom-DOMTokenList-toString">stringify</dfn> to the object's
underlying string representation.</p>

</div>


<h3>Interface <code>DOMSettableTokenList</code></h3>

<p>The <code>DOMSettableTokenList</code> interface is the same as the
<code>DOMTokenList</code> interface, except that it allows the
underlying string to be directly changed.</p>

<pre class="idl">interface <dfn>DOMSettableTokenList</dfn> : <span>DOMTokenList</span> {
            attribute DOMString <span title="dom-DOMSettableTokenList-value">value</span>;
};</pre>

<dl class="domintro">

 <dt><var>tokenlist</var> . <code title="dom-DOMSettableTokenList-value">value</code></dt>
 <dd>
  <p>Returns the underlying string.</p>
  <p>Can be set, to change the underlying string.</p>
 </dd>

</dl>

<div class="impl">

<p>An object implementing the <code>DOMSettableTokenList</code>
interface must act as defined for the <code>DOMTokenList</code>
interface, except for the <code
title="dom-DOMSettableTokenList-value">value</code> attribute defined
here.</p>

<p>The <dfn
title="dom-DOMSettableTokenList-value"><code>value</code></dfn>
attribute must return the underlying string on getting, and must
replace the underlying string with the new value on setting.</p>

</div>



<h2>Historical</h2>

<p>The interfaces and interface members listed in this section are part of
DOM Level 3 Core. Implementations conforming to this implementation will not
support them.</p>

<p>Interfaces:</p>
<ul class=brief>
 <li><dfn><code>DOMUserData</code></dfn>
 <li><dfn><code>DOMObject</code></dfn>
 <li><dfn><code>NameList</code></dfn>
 <li><dfn><code>DOMImplementationList</code></dfn>
 <li><dfn><code>DOMImplementationSource</code></dfn>
 <li><dfn><code>TypeInfo</code></dfn>
 <li><dfn><code>UserDataHandler</code></dfn>
 <li><dfn><code>DOMError</code></dfn>
 <li><dfn><code>DOMErrorHandler</code></dfn>
 <li><dfn><code>DOMLocator</code></dfn>
 <li><dfn><code>DOMConfiguration</code></dfn>
 <li><dfn><code>CDATASection</code></dfn>
 <li><dfn><code>Notation</code></dfn>
 <li><dfn><code>Entity</code></dfn>
 <li><dfn><code>EntityReference</code></dfn>
</ul>

<p>Interface members:</p>
<dl>
 <dt><code>Node</code></dt>
 <dd>
  <p><dfn title=dom-Node-normalize><code>normalize()</code></dfn>
  <p><dfn title=dom-Node-getFeature><code>getFeature()</code></dfn>
  <p><dfn title=dom-Node-getUserData><code>getUserData()</code></dfn>
  <p><dfn title=dom-Node-setUserData><code>setUserData()</code></dfn>

 <dt><code>Document</code></dt>
 <dd>
  <p><dfn title=dom-Document-createCDATASection><code>createCDATASection()</code></dfn>
  <p><dfn title=dom-Document-createAttribute><code>createAttribute()</code></dfn>
  <p><dfn title=dom-Document-createAttributeNS><code>createAttributeNS()</code></dfn>
  <p><dfn title=dom-Document-xmlEncoding><code>xmlEncoding</code></dfn>
  <p><dfn title=dom-Document-xmlStandalone><code>xmlStandalone</code></dfn>
  <p><dfn title=dom-Document-xmlVersion><code>xmlVersion</code></dfn>
  <p><dfn title=dom-Document-strictErrorChecking><code>strictErrorChecking</code></dfn>
  <p><dfn title=dom-Document-domConfig><code>domConfig</code></dfn>
  <p><dfn title=dom-Document-normalizeDocument><code>normalizeDocument()</code></dfn>
  <p><dfn title=dom-Document-renameNode><code>renameNode()</code></dfn>

 <dt><code>DOMImplementation</code>
 <dd>
  <p><dfn title=dom-DOMImplementation-getFeature><code>getFeature()</code></dfn>

 <dt><code>Attr</code>
 <dd>
  <p><dfn title=dom-Attr-schemaTypeInfo><code>schemaTypeInfo</code></dfn>
  <p><dfn title=dom-Attr-isId><code>isId</code></dfn>

 <dt><code>Element</code>
 <dd>
  <p><dfn title=dom-Element-getAttributeNode><code>getAttributeNode()</code></dfn>
  <p><dfn title=dom-Element-getAttributeNodeNS><code>getAttributeNodeNS()</code></dfn>
  <p><dfn title=dom-Element-setAttributeNode><code>setAttributeNode()</code></dfn>
  <p><dfn title=dom-Element-removeAttributeNode><code>removeAttributeNode()</code></dfn>
  <p><dfn title=dom-Element-schemaTypeInfo><code>schemaTypeInfo</code></dfn>
  <p><dfn title=dom-Element-setIdAttribute><code>setIdAttribute()</code></dfn>
  <p><dfn title=dom-Element-setIdAttributeNS><code>setIdAttributeNS()</code></dfn>
  <p><dfn title=dom-Element-setIdAttributeNode><code>setIdAttributeNode()</code></dfn>

 <dt><code>DocumentType</code>
 <dd>
  <p><dfn title=dom-DocumentType-entities><code>entities</code></dfn>
  <p><dfn title=dom-DocumentType-notations><code>notations</code></dfn>
  <p><dfn title=dom-DocumentType-internalSubset><code>internalSubset</code></dfn>

 <dt><code>Text</code>
 <dd>
  <p><dfn title=dom-Text-isElementContentWhitespace><code>isElementContentWhitespace</code></dfn>
</dl>



<h2 class="no-num" id="references">References</h2><!--REFS-->
<p>All references are normative unless marked "Non-normative".</p>

<!-- Dates are only included for standards older than the Web,
because the newer ones keep changing. -->

<div id=anolis-references></div>



<h2 class=no-num>Acknowledgements</h2>
<p>Thanks to

Anne van Kesteren,
Dethe Elza,
and
Henri Sivonen,

for their useful comments.

<p>Special thanks to Ian Hickson for first specifying some parts of this
specification in HTML. <span data-anolis-ref class=informative>HTML</span>


<script src="http://www.whatwg.org/specs/web-apps/current-work/dfn.js"></script>
