<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en-US">
 <head>
  <meta http-equiv=content-type content=text/html;charset=UTF-8>
  <title>DOM Core</title>
  <style type="text/css">
   pre.idl { border:solid thin; background:#eee; color:#000; padding:0.5em }
   pre.idl :link, pre.idl :visited { color:inherit; background:transparent }
   pre code { color:inherit; background:transparent }
   div.example { margin-left:1em; padding-left:1em; border-left:double; color:#222; background:#fcfcfc }
   .note { margin-left:2em; font-weight:bold; font-style:italic; color:#008000 }
   p.note::before { content:"Note: " }
   .XXX { padding:.5em; border:solid #f00 }
   p.XXX::before { content:"Issue: " }
   dl.switch { padding-left:2em }
   dl.switch > dt { text-indent:-1.5em }
   dl.switch > dt:before { content:'\21AA'; padding:0 0.5em 0 0; display:inline-block; width:1em; text-align:right; line-height:0.5em }
   dl.domintro { color: green; margin: 2em 0 2em 2em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
   dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
   dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
   dl.domintro dd p { margin: 0.5em 0; }
   dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This box is non-normative. Implementation requirements are given below this box.'; color: red; border: solid 2px; background: white; padding: 0 0.25em; }
   em.ct { text-transform:lowercase; font-variant:small-caps; font-style:normal }
   dfn { font-weight:bold; font-style:normal }
   code { color:orangered }
   code :link, code :visited { color:inherit }
   hr:not(.top) { display:block; background:none; border:none; padding:0; margin:2em 0; height:auto }
   table { border-collapse:collapse; border-style:hidden hidden none hidden }
   table thead { border-bottom:solid }
   table tbody th:first-child { border-left:solid }
   table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }

   .warning { color: red; background: transparent; font-weight: bolder; font-style: italic; }
   .warning p:first-child { margin-top: 0; }
   .warning p:last-child { margin-bottom: 0; }
   .warning:before { font-style: normal; }
   p.warning:before { content: '\26A0 Warning! '; }

   @media print {
     [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase }
   }
  </style>
  <link rel=stylesheet href="http://www.w3.org/StyleSheets/TR/W3C-[STATUS]">
 </head>
 <body>

<div class=head>
<!--logo-->
 <h1>DOM Core</h1>
 <h2 class="no-num no-toc">[LONGSTATUS] [DATE: 01 Jan 1901]</h2>

 <dl>
  <dt>This Version:
  <dd class=dontpublish><a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html">http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html</a>
  <dd class=publish><a href="[VERSION]">[VERSION]</a>

  <dt>Latest Version:
  <dd><a href="[LATEST]">[LATEST]</a>

  <dt class=publish>Latest Editor's Draft:
  <dd class=publish><a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html">http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html</a>

  <dt>Previous Versions:
  <dd><a href="http://www.w3.org/TR/2010/WD-domcore-20101007/">http://www.w3.org/TR/2010/WD-domcore-20101007/</a>

  <dt>Editors:
  <dd><a href="http://annevankesteren.nl/">Anne van Kesteren</a>
    (<a href="http://www.opera.com/">Opera Software ASA</a>)
    &lt;<a href="mailto:annevk@opera.com">annevk@opera.com</a>>
  <dd>Ms2ger (<a href="http://www.mozilla.org/">Mozilla Foundation</a>)
    &lt;<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>>
 </dl>
<!--copyright-->
</div>

<hr class="top">

<h2 class="no-num no-toc">Abstract</h2>
<p>DOM Core defines the event and document model the Web platform uses. The
DOM is a language- and platform neutral interface that allows programs and
scripts to dynamically access and update the content and structure of
documents.
<!-- XXX say something about exceptions? -->



<h2 class="no-num no-toc"><span id="sotd">Status of this Document</span></h2>
<p><i>This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current W3C
publications and the latest revision of this technical report can be found in
the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</i>

<p>This is the [DATE: 3 August 2002] [LONGSTATUS] of DOM Core. Please send
comments to
<a href="mailto:www-dom@w3.org?subject=%5BDOMCore%5D%20">www-dom@w3.org</a>
(<a href="http://lists.w3.org/Archives/Public/www-dom/">archived</a>)
with <samp>[DOMCore]</samp> at the start of the subject line.

<p>This document is produced by the
<a href="http://www.w3.org/2008/webapps/">Web Applications</a> (WebApps) Working
Group. The WebApps Working Group is part of the
<a href="http://www.w3.org/2006/rwc/Activity">Rich Web Clients Activity</a> in
the W3C <a href="http://www.w3.org/Interaction/">Interaction Domain</a>.

<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
W3C Patent Policy</a>. W3C maintains a
<a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/42538/status">public
list of any patent disclosures</a> made in connection with the deliverables of
the group; that page also includes instructions for disclosing a patent. An
individual who has actual knowledge of a patent which the individual believes
contains
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
Claim(s)</a> must disclose the information in accordance with
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
6 of the W3C Patent Policy</a>.

<p>Publication as a Working Draft does not imply endorsement by the W3C
Membership. This is a draft document and may be updated, replaced or
obsoleted by other documents at any time. It is inappropriate to cite this
document as other than work in progress.



<h2 class="no-num no-toc">Table of Contents</h2>
<!--toc-->



<h2 class=no-num>Goals</h2>

<p>The goal of this specification is taking all of DOM Level 3 Core and the
"DOM Event Architecture" and "Basic Event Interfaces" chapters of
DOM Level 3 Events (specific type of events do not belong in the base
specification) and do the following:
<span data-anolis-ref class=informative>DOM3CORE</span>
<span data-anolis-ref class=informative>DOM3EVENTS</span>

<ul>
 <li>Align them with the needs of ECMAScript where possible.
 <li>Align them with existing implementations.
 <li>Simplify them as much as possible.
 <li>Import bits of HTML5 that ought to be in DOM Core.
 <li>Prevent a dependency on HTML5.
</ul>

<p>New features might be added, once everything else is sort of stable.


<h2 class=no-num>Issues</h2>

<ul class=XXX>
 <li>Node.baseURI
 <li>Node.compareDocumentPosition
 <li>Document.documentURI
 <li>Move DOMStringMap here?
 <li>Move Document.charset / Document.characterSet / Document.defaultCharset here?
</ul>


<h2>Conformance</h2>
<p>All diagrams, examples, and notes in this specification are
non-normative, as are all sections explicitly marked non-normative.
Everything else in this specification is normative.

<p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
NOT",--> "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in the normative parts of this document are to be
interpreted as described in RFC2119. For readability, these words do
not appear in all uppercase letters in this specification. <span
data-anolis-ref>RFC2119</span>

<p>Requirements phrased in the imperative as part of algorithms
(such as "strip any leading space characters" or "return false and
terminate these steps") are to be interpreted with the meaning of the
key word ("must", "should", "may", etc) used in introducing the
algorithm.

<p>Conformance requirements phrased as algorithms or specific steps
may be implemented in any manner, so long as the end result is
equivalent. (In particular, the algorithms defined in this
specification are intended to be easy to follow, and not intended to
be performant.)

<p id="hardwareLimitations">User agents may impose
implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running
out of memory, or to work around platform-specific limitations.

<p>When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can't change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.

<p>Unless otherwise stated, string comparisons are done in a <span>case-sensitive</span> manner.

<h3>Dependencies</h3>

<p>The IDL fragments in this specification must be interpreted as
required for conforming IDL fragments, as described in the Web IDL
specification. <span data-anolis-ref>WEBIDL</span>

<p>Some of the terms used in this specification are defined in
<cite>Web IDL</cite>, <cite>XML</cite> and <cite>Namespaces in XML</cite>.
<span data-anolis-ref>WEBIDL</span>
<span data-anolis-ref>XML</span>
<span data-anolis-ref>XMLNS</span>

<h3>Extensibility</h3>

<p>Vendor-specific proprietary extensions to this specification are
strongly discouraged. Authors must not use such extensions, as
doing so reduces interoperability and fragments the user base,
allowing only users of specific user agents to access the content in
question.

<p>If vendor-specific extensions are needed, the members should be
prefixed by vendor-specific strings to prevent clashes with future
versions of this specification. Extensions must be defined so that
the use of extensions neither contradicts nor causes the
non-conformance of functionality defined in the specification.
<!-- thanks to QA Framework -->

<p>When vendor-neutral extensions to this specification are needed,
either this specification can be updated accordingly, or an
extension specification can be written that overrides the
requirements in this specification. When someone applying this
specification to their activities decides that they will recognise
the requirements of such an extension specification, it becomes an
<dfn title="other applicable specifications">applicable
specification</dfn> for the purposes of conformance requirements in
this specification.
<!-- http://www.w3.org/mid/17E341CD-E790-422C-9F9A-69347EE01CEB@iki.fi -->


<h2>Terminology</h2>

<p>The term <dfn>context object</dfn> means the object on which the method
or attribute being discussed was called. When the <span>context object</span>
is unambiguous, the term can be omitted.


<h3>Trees</h3> <!-- Sorry reddit, this is not /r/trees -->

<p>Just like most programming paradigms the Web platform has finite
hierarchical tree structures, simply named
<dfn title=concept-tree>trees</dfn>.

<p>An object that <dfn title=concept-tree-participate>participates</dfn> in
a <span title=concept-tree>tree</span> has a
<dfn title=concept-tree-parent>parent</dfn>, which is either another object
or null, and an ordered list of zero or more
<dfn title=concept-tree-child>child</dfn> objects.

<p>An object whose <span title=concept-tree-parent>parent</span> is null is
called the <dfn title=concept-tree-root>root</dfn> object.

<p>An object <var title>A</var> is called a
<dfn title=concept-tree-descendant>descendant</dfn> of an object
<var title>B</var>, if either <var title>A</var> is a
<span title=concept-tree-child>child</span> of <var title>B</var> or
<var title>A</var> is a <span title=concept-tree-child>child</span> of an
object <var title>C</var> that is a
<span title=concept-tree-descendant>descendant</span> of <var title>B</var>.

<p>An object <var title>A</var> is called an
<dfn title=concept-tree-ancestor>ancestor</dfn> of an object
<var title>B</var> if and only if <var title>B</var> is a
<span title=concept-tree-descendant>descendant</span> of
<var title>A</var>.

<p>An object <var title>A</var> is called a
<dfn title=concept-tree-sibling>sibling</dfn> of an object
<var title>B</var>, if and only if <var title>B</var> and <var title>A</var>
share the same non-null <span title=concept-tree-parent>parent</span>.
<var title>A</var> is a
<dfn title=concept-tree-preceding-sibling>preceding sibling</dfn> of
<var title>B</var> if <var title>A</var> and <var title>B</var> are
<span title=concept-tree-sibling>siblings</span> and <var title>A</var>
comes before <var title>B</var> in their shared
<span title=concept-tree-parent>parent</span>.
<var title>A</var> is a
<dfn title=concept-tree-following-sibling>following sibling</dfn> of
<var title>B</var> if <var title>A</var> and <var title>B</var> are
<span title=concept-sibling-node>siblings</span> and <var title>A</var>
comes after <var title>B</var> in their shared
<span title=concept-tree-parent>parent</span>.

<hr>

<p>The term <dfn>tree order</dfn> means a pre-order, depth-first traversal
of a <span title=concept-tree>tree</span>.
<!-- XXX should that use concept- ? -->
<!-- http://en.wikipedia.org/wiki/Tree_traversal#Depth-first_Traversal -->


<h3>Strings</h3>
<p>Comparing two strings in a <dfn>case-sensitive</dfn> manner means comparing them exactly, codepoint for codepoint.

<p>Comparing two strings in a <dfn>ASCII case-insensitive</dfn> manner means comparing them exactly, codepoint for codepoint, except that the characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.

<p><dfn title="converted to uppercase">Converting a string to uppercase</dfn> means replacing all characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) with the corresponding characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z).

<p><dfn title="converted to lowercase">Converting a string to lowercase</dfn> means replacing all characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).

<p>A string <var title>pattern</var> is a <dfn>prefix match</dfn> for a string
<var title>s</var> when <var title>pattern</var> is not longer than
<var title>s</var> and truncating <var title>s</var> to
<var title>pattern</var>'s length leaves the two strings as matches of each
other.

<p>The <dfn title="space character">space characters</dfn>, for the
purposes of this specification, are U+0020 SPACE, U+0009 CHARACTER
TABULATION (tab), U+000A LINE FEED (LF), U+000C FORM FEED (FF), and
U+000D CARRIAGE RETURN (CR).


<h3>Common microsyntaxes</h3>
<h4>Common parser idioms</h4>
<p>Some of the micro-parsers described below follow the pattern of having an
<var title>input</var> variable that holds the string being parsed, and having a
<var title>position</var> variable pointing at the next character to parse in
<var title>input</var>.

<p>For parsers based on this pattern, a step that requires the user agent to
<dfn>collect a sequence of characters</dfn> means that the following algorithm
must be run, with <var title>characters</var> being the set of characters that
can be collected:

<ol>
 <li><p>Let <var title>input</var> and <var title>position</var> be the same
 variables as those of the same name in the algorithm that invoked these steps.

 <li><p>Let <var title>result</var> be the empty string.

 <li><p>While <var title>position</var> does not point past the end of
 <var title>input</var> and the character at <var title>position</var> is one of
 the <var title>characters</var>, append that character to the end of
 <var title>result</var> and advance <var title>position</var> to the next
 character in <var title>input</var>.

 <li><p>Return <var title>result</var>.
</ol>

<p>The step <dfn>skip whitespace</dfn> means that the user agent
must <span>collect a sequence of characters</span> that are <span
title="space character">space characters</span>. The collected
characters are not used.

<h4>Space-separated tokens</h4>

<p>A <dfn>set of space-separated tokens</dfn> is a string containing
zero or more words (known as tokens) separated by one or more <span
title="space character">space characters</span>, where words consist
of any string of one or more characters, none of which are <span
title="space character">space characters</span>.

<p>A string containing a <span>set of space-separated tokens</span>
may have leading or trailing <span title="space character">space
characters</span>.

<p>An <dfn>unordered set of unique space-separated tokens</dfn> is a
<span>set of space-separated tokens</span> where none of the tokens
are duplicated.

<p>An <dfn>ordered set of unique space-separated tokens</dfn> is a
<span>set of space-separated tokens</span> where none of the tokens
are duplicated but where the order of the tokens is meaningful.

<p><span title="set of space-separated tokens">Sets of
space-separated tokens</span> sometimes have a defined set of
allowed values. When a set of allowed values is defined, the tokens
must all be from that list of allowed values; other values are
non-conforming. If no such set of allowed values is provided, then
all values are conforming.

<p class="note">How tokens in a <span>set of space-separated
tokens</span> are to be compared (e.g. case-sensitively or not) is
defined on a per-set basis.

<div class="impl">

<p>When a user agent has to <dfn>split a string on spaces</dfn>, it
must use the following algorithm:

<ol>
 <li><p>Let <var title>input</var> be the string being parsed.

 <li><p>Let <var title>position</var> be a pointer into <var title>input</var>,
 initially pointing at the start of the string.

 <li><p>Let <var title>tokens</var> be a list of tokens, initially empty.

 <li><p><span>Skip whitespace</span>.

 <li><p>While <var title>position</var> is not past the end of
 <var title>input</var>:

  <ol>
   <li><p><span>Collect a sequence of characters</span> that are not
   <span title="space character">space characters</span>.

   <li><p>Add the string collected in the previous step to
   <var title>tokens</var>.

   <li><p><span>Skip whitespace</span>.
  </ol>

 <li><p>Return <var title>tokens</var>.
</ol>

<p>When a user agent has to <dfn>remove a token from a string</dfn>,
it must use the following algorithm:

<ol>
 <li><p>Let <var title>input</var> be the string being modified.

 <li><p>Let <var title>token</var> be the token being removed. It will not
 contain any <span title="space character">space characters</span>.

 <li><p>Let <var title>output</var> be the output string, initially empty.

 <li><p>Let <var title>position</var> be a pointer into <var title>input</var>,
 initially pointing at the start of the string.

 <li><p><i title>Loop</i>: If <var title>position</var> is beyond the end of
 <var title>input</var>, terminate these steps.

 <li>
  <p>If the character at <var title>position</var> is a <span>space
  character</span>:

  <ol>
   <li><p>Append the character at <var title>position</var> to the end of <var
   title>output</var>.

   <li><p>Advance <var title>position</var> so it points at the next character
   in <var title>input</var>.

   <li><p>Return to the step labeled <i title>loop</i>.
  </ol>

 <li><p>Otherwise, the character at <var title>position</var> is the first
 character of a token. <span>Collect a sequence of characters</span> that are
 not <span title="space character">space characters</span>, and let that be <var
 title>s</var>.

 <li>
  <p>If <var title>s</var> is exactly equal to <var title>token</var>, then:

  <ol>
   <li><p><span>Skip whitespace</span> (in <var title>input</var>).

   <li><p>Remove any <span title="space character">space characters</span>
   currently at the end of <var title>output</var>.

   <li><p>If <var title>position</var> is not past the end of <var
   title>input</var>, and <var title>output</var> is not the empty string,
   append a single U+0020 SPACE character at the end of <var title>output</var>.
  </ol>

 <li><p>Otherwise, append <var title>s</var> to the end of <var
 title>output</var>.

 <li><p>Return to the step labeled <i title>loop</i>.
</ol>

<p class="note">This causes any occurrences of the token to be
removed from the string, and any spaces that were surrounding the
token to be collapsed to a single space, except at the start and end
of the string, where such spaces are removed.

</div>


<h3>Namespaces</h3>
<p>The <dfn>HTML namespace</dfn> is <code
title>http://www.w3.org/1999/xhtml</code>.

<p>The <dfn>XML namespace</dfn> is <code
title>http://www.w3.org/XML/1998/namespace</code>.

<p>The <dfn>XMLNS namespace</dfn> is <code
title>http://www.w3.org/2000/xmlns/</code>.


<h2>Exceptions</h2>
<h3>Exception <code>DOMException</code></h3>
<pre class=idl>exception <dfn>DOMException</dfn> {
  const unsigned short <span title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</span> = 1;
  const unsigned short <span title=dom-DOMException-DOMSTRING_SIZE_ERR>DOMSTRING_SIZE_ERR</span> = 2; // historical
  const unsigned short <span title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</span> = 3;
  const unsigned short <span title=dom-DOMException-WRONG_DOCUMENT_ERR>WRONG_DOCUMENT_ERR</span> = 4;
  const unsigned short <span title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</span> = 5;
  const unsigned short <span title=dom-DOMException-NO_DATA_ALLOWED_ERR>NO_DATA_ALLOWED_ERR</span> = 6; // historical
  const unsigned short <span title=dom-DOMException-NO_MODIFICATION_ALLOWED_ERR>NO_MODIFICATION_ALLOWED_ERR</span> = 7;
  const unsigned short <span title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</span> = 8;
  const unsigned short <span title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</span> = 9;
  const unsigned short <span title=dom-DOMException-INUSE_ATTRIBUTE_ERR>INUSE_ATTRIBUTE_ERR</span> = 10; // historical
  const unsigned short <span title=dom-DOMException-INVALID_STATE_ERR>INVALID_STATE_ERR</span> = 11;
  const unsigned short <span title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</span> = 12;
  const unsigned short <span title=dom-DOMException-INVALID_MODIFICATION_ERR>INVALID_MODIFICATION_ERR</span> = 13;
  const unsigned short <span title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</span> = 14;
  const unsigned short <span title=dom-DOMException-INVALID_ACCESS_ERR>INVALID_ACCESS_ERR</span> = 15;
  const unsigned short <span title=dom-DOMException-VALIDATION_ERR>VALIDATION_ERR</span> = 16; // historical
  const unsigned short <span title=dom-DOMException-TYPE_MISMATCH_ERR>TYPE_MISMATCH_ERR</span> = 17;
  const unsigned short <span title=dom-DOMException-SECURITY_ERR>SECURITY_ERR</span> = 18;
  const unsigned short <span title=dom-DOMException-NETWORK_ERR>NETWORK_ERR</span> = 19;
  const unsigned short <span title=dom-DOMException-ABORT_ERR>ABORT_ERR</span> = 20;
  const unsigned short <span title=dom-DOMException-URL_MISMATCH_ERR>URL_MISMATCH_ERR</span> = 21;
  const unsigned short <span title=dom-DOMException-QUOTA_EXCEEDED_ERR>QUOTA_EXCEEDED_ERR</span> = 22;
  const unsigned short <span title=dom-DOMException-TIMEOUT_ERR>TIMEOUT_ERR</span> = 23;
  const unsigned short <span title=dom-DOMException-INVALID_NODE_TYPE_ERR>INVALID_NODE_TYPE_ERR</span> = 24;
  const unsigned short <span title=dom-DOMException-DATA_CLONE_ERR>DATA_CLONE_ERR</span> = 25;
  unsigned short <span title=dom-DOMException-code>code</span>;
  DOMString <span title=dom-DOMException-name>name</span>;
};</pre>

<p>The <dfn title=dom-DOMException-code><code>code</code></dfn> exception
field must return the code for the exception, which must be one of the
following:

<ul class="brief">
 <li><dfn title=dom-DOMException-INDEX_SIZE_ERR><code>INDEX_SIZE_ERR</code></dfn> (1):
 the index is not in the allowed range;
 <li><dfn title=dom-DOMException-DOMSTRING_SIZE_ERR><code>DOMSTRING_SIZE_ERR</code></dfn> (2):
 the text does not fit in a <code data-anolis-spec=webidl>DOMString</code>
 (historical);
 <li><dfn title=dom-DOMException-HIERARCHY_REQUEST_ERR><code>HIERARCHY_REQUEST_ERR</code></dfn> (3):
 the operation would yield an incorrect nodes model; <!-- XXXhierarchy -->
 <li><dfn title=dom-DOMException-WRONG_DOCUMENT_ERR><code>WRONG_DOCUMENT_ERR</code></dfn> (4):
 the object is in the wrong <code>Document</code>, a call to <code
 title=dom-Document-importNode>importNode</code> is required;
 <li><dfn title=dom-DOMException-INVALID_CHARACTER_ERR><code>INVALID_CHARACTER_ERR</code></dfn> (5):
 the string contains invalid characters;
 <li><dfn title=dom-DOMException-NO_DATA_ALLOWED_ERR><code>NO_DATA_ALLOWED_ERR</code></dfn> (6):
 data is specified for an object that does not support it (historical);
 <li><dfn title=dom-DOMException-NO_MODIFICATION_ALLOWED_ERR><code>NO_MODIFICATION_ALLOWED_ERR</code></dfn> (7):
 the object can not be modified;
 <li><dfn title=dom-DOMException-NOT_FOUND_ERR><code>NOT_FOUND_ERR</code></dfn> (8):
 the object can not be found here;
 <li><dfn title=dom-DOMException-NOT_SUPPORTED_ERR><code>NOT_SUPPORTED_ERR</code></dfn> (9):
 this operation is not supported;
 <li><dfn title=dom-DOMException-INUSE_ATTRIBUTE_ERR><code>INUSE_ATTRIBUTE_ERR</code></dfn> (10):
 the attribute is in use (historical)<!--createAttribute-->;
 <li><dfn title=dom-DOMException-INVALID_STATE_ERR><code>INVALID_STATE_ERR</code></dfn> (11):
 the object is in an invalid state;
 <li><dfn title=dom-DOMException-SYNTAX_ERR><code>SYNTAX_ERR</code></dfn> (12):
 the string did not match the expected pattern;
 <li><dfn title=dom-DOMException-INVALID_MODIFICATION_ERR><code>INVALID_MODIFICATION_ERR</code></dfn> (13):
 the object can not be modified in this way;
 <li><dfn title=dom-DOMException-NAMESPACE_ERR><code>NAMESPACE_ERR</code></dfn> (14):
 the operation is not allowed by <cite>Namespaces in XML</cite>; <span
 data-anolis-ref>XMLNS</span>
 <li><dfn title=dom-DOMException-INVALID_ACCESS_ERR><code>INVALID_ACCESS_ERR</code></dfn> (15):
 the object does not support the operation or argument;
 <li><dfn title=dom-DOMException-VALIDATION_ERR><code>VALIDATION_ERR</code></dfn> (16):
 the operation is invalid (historical);
 <li><dfn title=dom-DOMException-TYPE_MISMATCH_ERR><code>TYPE_MISMATCH_ERR</code></dfn> (17):
 the type of the object does not match the expected type;
 <!-- XHR -->
 <li><dfn title=dom-DOMException-SECURITY_ERR><code>SECURITY_ERR</code></dfn> (18):
 the operation is insecure;
 <!-- XHR -->
 <li><dfn title=dom-DOMException-NETWORK_ERR><code>NETWORK_ERR</code></dfn> (19):
 a network error occurred;
 <!-- XHR -->
 <li><dfn title=dom-DOMException-ABORT_ERR><code>ABORT_ERR</code></dfn> (20):
 the user aborted an operation;
 <!-- Workers -->
 <li><dfn title=dom-DOMException-URL_MISMATCH_ERR><code>URL_MISMATCH_ERR</code></dfn> (21):
 the given URL does not match another URL;
 <!-- HTML -->
 <li><dfn title=dom-DOMException-QUOTA_EXCEEDED_ERR><code>QUOTA_EXCEEDED_ERR</code></dfn> (22):
 the quota has been exceeded;
 <!-- XHR2 -->
 <li><dfn title=dom-DOMException-TIMEOUT_ERR><code>TIMEOUT_ERR</code></dfn> (23):
 a timeout occurred;
 <!-- DOM Range -->
 <li><dfn title=dom-DOMException-INVALID_NODE_TYPE_ERR><code>INVALID_NODE_TYPE_ERR</code></dfn> (24):
 the supplied node is invalid or has an invalid ancestor for this operation;
 <!-- HTML -->
 <li><dfn title=dom-DOMException-DATA_CLONE_ERR><code>DATA_CLONE_ERR</code></dfn> (25):
 the object can not be cloned.
</ul>

<p>The <dfn title=dom-DOMException-name><code>name</code></dfn> exception
field must return the name of the exception constant as a string.


<h2>Events</h2>

<p class=XXX>This chapter provides an alternative definition for the
"DOM Event Architecture" and "Basic Event Interfaces" chapters of
DOM Level 3 Events. We would appreciate your input on which approach you
prefer.

<h3>Interface <code>Event</code></h3>

<pre class="idl">interface <dfn>Event</dfn> {
  readonly attribute DOMString <span title=dom-Event-type>type</span>;
  readonly attribute <span>EventTarget</span> <span title=dom-Event-target>target</span>;
  readonly attribute <span>EventTarget</span> <span title=dom-Event-currentTarget>currentTarget</span>;

  const unsigned short <span title=dom-Event-CAPTURING_PHASE>CAPTURING_PHASE</span> = 1;
  const unsigned short <span title=dom-Event-AT_TARGET>AT_TARGET</span> = 2;
  const unsigned short <span title=dom-Event-BUBBLING_PHASE>BUBBLING_PHASE</span> = 3;
  readonly attribute unsigned short <span title=dom-Event-eventPhase>eventPhase</span>;

  void <span title=dom-Event-stopPropagation>stopPropagation</span>();
  void <span title=dom-Event-stopImmediatePropagation>stopImmediatePropagation</span>();

  readonly attribute boolean <span title=dom-Event-bubbles>bubbles</span>;
  readonly attribute boolean <span title=dom-Event-cancelable>cancelable</span>;
  void <span title=dom-Event-preventDefault>preventDefault</span>();
  readonly attribute boolean <span title=dom-Event-defaultPrevented>defaultPrevented</span>;

  readonly attribute boolean <span title=dom-Event-isTrusted>isTrusted</span>;
  readonly attribute DOMTimeStamp <span title=dom-Event-timeStamp>timeStamp</span>;

  void <span title=dom-Event-initEvent>initEvent</span>(DOMString <var title>type</var>, boolean <var title>bubbles</var>, boolean <var title>cancelable</var>);
};</pre>

<p>An <dfn title=concept-event>event</dfn> allows for signaling that something has occurred. E.g. that an image has completed downloading.</p>

<p>Each <span title=concept-event>event</span> has a <dfn title=concept-event-type>type</dfn> which is initially the empty string. The
<dfn title=dom-Event-type><code>type</code></dfn> attribute must
return the <span title=concept-event-type>type</span>.</p>

<p>Each <span title=concept-event>event</span> has an associated
<dfn title=concept-event-target>target</dfn> and
<dfn title=concept-event-current-target>current target</dfn> which are both
initially null and then set while
<span title=concept-event-dispatch>dispatching</span> the
<span title=concept-event>event</span>. The
<dfn title=dom-Event-target><code>target</code></dfn> attribute must return
the <span title=concept-event-target>target</span> and the
<dfn title=dom-Event-currentTarget><code>currentTarget</code></dfn>
attribute must return the
<span title=concept-event-current-target>current target</span>.

<p>Each <span title=concept-event>event</span> has a
<dfn title=concept-event-phase>phase</dfn>. The
<dfn title=dom-Event-eventPhase><code>eventPhase</code></dfn> attribute must
return the current <span title=concept-event-phase>phase</span>, which must
be one of the following:</p>
<dl>
 <dt><dfn title=dom-Event-CAPTURING_PHASE><code>CAPTURING_PHASE</code></dfn> (numeric value 1)</dt>
 <dd><p>When an <span title=concept-event>event</span> is
 <span title=concept-event-dispatch>dispatched</span> on an object that
 <span title=concept-tree-participate>participates</span> in a
 <span title=concept-tree>tree</span> it will be in this phase before it
 reaches its <span title=concept-event-target>target</span>.
 <dt><dfn title=dom-Event-AT_TARGET><code>AT_TARGET</code></dfn> (numeric value 2)
 <dd><p>When an <span title=concept-event>event</span> is <span title=concept-event-dispatch>dispatched</span> it will be in this phase on its <span title=concept-event-target>target</span>.
 <dt><dfn title=dom-Event-BUBBLING_PHASE><code>BUBBLING_PHASE</code></dfn> (numeric value 3)
 <dd><p>When an <span title=concept-event>event</span> is
 <span title=concept-event-dispatch>dispatched</span> on an object that
 <span title=concept-tree-participate>participates</span> in a
 <span title=concept-tree>tree</span> it will be in this phase after it
 reaches its <span title=concept-event-target>target</span>.
</dl>
<p>Initially the <span title=concept-event-phase>phase</span> is
<span title=dom-Event-AT_TARGET>AT_TARGET</span>.

<p>Each <span title=concept-event>event</span> has the following associated
flags that are all initially unset:</p>
<ul>
 <li><dfn>stop propagation flag</dfn>
 <li><dfn>stop immediate propagation flag</dfn>
 <li><dfn>bubble flag</dfn>
 <li><dfn>cancel flag</dfn>
 <li><dfn>canceled flag</dfn>
 <li><dfn>trusted flag</dfn>
 <li><dfn>initialized flag</dfn>
 <li><dfn>dispatch flag</dfn>
</ul>
<p>When the
<dfn title=dom-Event-stopPropagation><code>stopPropagation()</code></dfn>
method is invoked the <span>stop propagation flag</span> must be set.
<p>When the
<dfn title=dom-Event-stopImmediatePropagation><code>stopImmediatePropagation()</code></dfn>
method is invoked both the <span>stop propagation flag</span> and
<span>stop immediate propagation flag</span> must be set.
<p>The <dfn title=dom-Event-bubbles><code>bubbles</code></dfn> attribute
must return true if the <span>bubble flag</span> is set and false otherwise.
<p>The <dfn title=dom-Event-cancelable><code>cancelable</code></dfn>
attribute must return true if the <span>cancel flag</span> is set and false
otherwise.
<p>When the
<dfn title=dom-Event-preventDefault><code>preventDefault()</code></dfn>
method is invoked and the <span>cancel flag</span> is set, the
<span>canceled flag</span> must be set.
<p>The <dfn title=dom-Event-defaultPrevented><code>defaultPrevented</code></dfn>
attribute must return true if the <span>canceled flag</span> is set and
false otherwise.

<p>The <dfn title=dom-Event-isTrusted><code>isTrusted</code></dfn> attribute
must return true if the <span>trusted flag</span> is set and false
otherwise.

<p class="XXX">The <dfn title=dom-Event-timeStamp><code>timeStamp</code></dfn>
attribute ... <a href="http://www.w3.org/2008/webapps/track/issues/172">More information.</a>

<p>When the <dfn title=dom-Event-initEvent><code>initEvent(<var title>type</var>, <var title>bubbles</var>, <var title>cancelable</var>)</code></dfn>
method is invoked these steps must be run:</p>

<ol>
 <li><p>Set the <span>initialized flag</span>.
 <li><p>If the <span>dispatch flag</span> is set, terminate these steps.
 <li><p>Unset the <span>stop propagation flag</span>,
 <span>stop immediate propagation flag</span>, <span>canceled flag</span>,
 and <span>trusted flag</span>.
 <li><p>Set <span title=concept-event-target>target</span> to null.
 <li><p>Set <span title=concept-event-type>type</span> to the
 <var title>type</var> argument.
 <li><p>If the <var title>bubbles</var> argument is true, set the
 <span>bubble flag</span>.
 <li><p>If the <var title>cancelable</var> argument is true, set the
 <span>cancel flag</span>.
</ol>


<h3>Interface <code>CustomEvent</code></h3>

<pre class=idl>interface <dfn>CustomEvent</dfn> : <span>Event</span> {
  readonly attribute object <span title=dom-CustomEvent-detail>detail</span>;
  void <span title=dom-CustomEvent-initCustomEvent>initCustomEvent</span>(DOMString <var title>type</var>, boolean <var title>bubbles</var>, boolean <var title>cancelable</var>, object <var title>detail</var>);
};</pre>

<p><span title=concept-event>Events</span> using the
<code>CustomEvent</code> interface can be used for synthetic events that
need to carry data.</p>

<p><span title=concept-event>Events</span> using the
<code>CustomEvent</code> interface have an associated
<dfn title=concept-CustomEvent-detail>detail</dfn> variable. The
<dfn title=dom-CustomEvent-detail><code>detail</code></dfn> attribute must
return <span title=concept-CustomEvent-detail>detail</span>, if it is set,
and null otherwise.

<p>When the <dfn title=dom-CustomEvent-initCustomEvent><code>initCustomEvent(<var title>type</var>, <var title>bubbles</var>, <var title>cancelable</var>, <var title>detail</var>)</code></dfn>
method is invoked these steps must be run:</p>

<ol>
 <li><p>If the <span>dispatch flag</span> is set, terminate these steps.
 <li><p>Invoke <code title=dom-Event-initEvent>initEvent()</code> with the
 first three arguments.</li>
 <li><p>Set <span title=concept-CustomEvent-detail>detail</span> to the
 <var title>detail</var> argument.
</ol>


<h3>Interface <code>EventTarget</code></h3>

<pre class=idl>interface <dfn>EventTarget</dfn> {
  void <span title=dom-EventTarget-addEventListener>addEventListener</span>(DOMString <var title>type</var>, <span>EventListener</span> <var title>listener</var>, optional boolean <var title>capture</var>);
  void <span title=dom-EventTarget-removeEventListener>removeEventListener</span>(DOMString <var title>type</var>, <span>EventListener</span> <var title>listener</var>, optional boolean <var title>capture</var>);
  boolean <span title=dom-EventTarget-dispatchEvent>dispatchEvent</span>(<span>Event</span> <var title>event</var>);
};

[Callback] interface <dfn>EventListener</dfn> {
  void <span title=dom-EventListener-handleEvent>handleEvent</span>(<span>Event</span> <var title>event</var>);
};</pre>

<p><code>EventTarget</code> is an object upon which an
<span title=concept-event>event</span> is <span>dispatched</span>
when something has occurred. Each <code>EventTarget</code> has an associated
list of <span title=concept-event-listener>event listeners</span>.

<p>An <dfn title=concept-event-listener>event listener</dfn> is a handler
for a specific <span title=concept-event>event</span>. Each
<span title=concept-event-listener>event listener</span> consists of a
<b>name</b> (of the <span title=concept-event>event</span>),
<b>listener</b>, and <b>capture</b> variable.

<p>When the
<dfn title=dom-EventTarget-addEventListener><code>addEventListener(<var title>type</var>, <var title>listener</var>, <var title>capture</var>)</code></dfn>
method is invoked these steps must be run:
<ol>
 <li><p>If <var title>listener</var> is null terminate these steps.
 <li><p>If <var title>capture</var> is omitted let <var title>capture</var> be false.
 <li><p>Append an <span title=concept-event-listener>event listener</span>
 to the associated list of
 <span title=concept-event-listener>event listeners</span> with <b>name</b>
 set to <var title>type</var>, <b>listener</b> set to <var title>listener</var>, and
 <b>capture</b> set to <var title>capture</var>, unless there
 already is an <span title=concept-event-listener>event listener</span> in
 that list with the same <b>name</b>, <b>listener</b>, and <b>capture</b>.
</ol>

<p>When the <dfn title=dom-EventTarget-removeEventListener><code>removeEventListener(<var title>type</var>, <var title>listener</var>, <var title>capture</var>)</code></dfn> method is invoked these steps must be run:
<ol>
 <li><p>If <var title>capture</var> is omitted let <var title>capture</var> be false.
 <li><p>Remove an <span title=concept-event-listener>event listener</span>
 from the associated list of
 <span title=concept-event-listener>event listeners</span>, whose
 <b>name</b> is <var title>name</var>, <b>listener</b> is <var title>listener</var>, and
 <b>capture</b> is <var title>capture</var>.</p>
</ol>

<p>When the
<dfn title=dom-EventTarget-dispatchEvent><code>dispatchEvent(<var title>event</var>)</code></dfn> method is invoked these steps must be run:
<ol>
 <li><p>If <var title>event</var>'s <span>dispatch flag</span> is set, or if its
 <span>initialized flag</span> isn't set, throw an
 <code title=dom-DOMException-INVALID_STATE_ERR>INVALID_STATE_ERR</code>
 exception and terminate these steps.
 <li><p>Unset <var title>event</var>'s <span>trusted flag</span>.
 <li><p><span title=concept-event-dispatch>Dispatch</span> the
 <var title>event</var> and return the value that returns.
</ol>


<h3>Creating Events</h3>

<p class=note>Although the <code>Document</code> object is introduced later
it was thought better to describe its
<code title=dom-Document-createEvent>createEvent()</code> method here.

<p>When the <dfn title=dom-Document-createEvent><code>createEvent(<var title>interface</var>)</code></dfn> methed is invoked these steps must be run:

<ol>
 <li>
  <p>If <var title>interface</var> is an <span>ASCII case-insensitive</span>
  match for any of the strings in the first column in the following table
  let <var title>interface</var> be the string in the second column on the same
  row as the matching string:</p>
  <table>
  <thead>
   <tr><th>Input interface <th>Replacement interface
  <tbody>
   <tr><td>"<code title>htmlevents</code>"<td>"<code title>event</code>"
   <tr><td>"<code title>mouseevents</code>"<td>"<code title>mouseevent</code>"
   <tr><td>"<code title>mutationevents</code>"<td>"<code title>mutationevent</code>"
   <tr><td>"<code title>uievents</code>"<td>"<code title>uievent</code>"
  </table>
  <!-- XXX WebKit/Gecko (IE?) support "events" -> "event". Add it or make sure it's not supported? -->
 </li>
 <li><p>If <var title>interface</var> is <em>not</em> an
 <span>ASCII case-insensitive</span> match for "<code title>event</code>" or
 for the name of an interface that inherits from the <code>Event</code>
 interface and is supported by the user agent, throw a
 <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code> and
 terminate these steps.
 <li><p>Create an <span title=concept-event>event</span> implementing the
 interface whose name <var title>interface</var> is an
 <span>ASCII case-insensitive</span> match for and return it.
</ol>

<p class=note>Because <code title=dom-Document-createEvent>createEvent()</code> is located on the <code>Document</code> object it cannot be used by Web Workers. Please let us know if this bothers you.


<h3>Dispatching Events</h3>

<p>To <dfn title=concept-event-dispatch>dispatch</dfn> an
<span title=concept-event>event</span> on a given object run these
steps:</p>
<!-- other specifications turn this into a requirement  -->

<ol>
 <li><p>Let <var title>event</var> be the
 <span title=concept-event>event</span> that is dispatched.
 <li><p>Set <var title>event</var>'s <span>dispatch flag</span>.
 <li><p>Set <var title>event</var>'s
 <span title=concept-event-target>target</span> to the object on which
 <var title>event</var> is dispatched.
 <li>
  <dl>
   <dt>If <var title>event</var>'s
   <span title=concept-event-target>target</span> is
   <span title=concept-tree-participate>participating</span> in a
   <span title=concept-tree>tree</span>
   <dd>
    <ol>
     <li><p>Let <var title>event path</var> be a static ordered list of all
     <span title=concept-tree-ancestor>ancestors</span> of
     <var title>event</var>'s <span title=concept-event-target>target</span>
     in <span>tree order</span>.</li>
     <li><p>Set <var title>event</var>'s <span title=concept-event-phase>phase</span> to <span title=dom-Event-CAPTURING_PHASE>CAPTURING_PHASE</span>.
     <li><p>For each object in the <var title>event path</var>
     <span title=concept-event-listener-invoke>invoke</span> its
     <span title=concept-event-listener>event listeners</span>, as long as
     <var title>event</var>'s <span>stop propagation flag</span> is unset.
     <li><p>Set <var title>event</var>'s <span title=concept-event-phase>phase</span> to <span title=dom-Event-AT_TARGET>AT_TARGET</span>.
     <li><p><span title=concept-event-listener-invoke>Invoke</span> the
     <span title=concept-event-listener>event listeners</span> of
     <var title>event</var>'s
     <span title=concept-event-target>target</span>, if
     <var title>event</var>'s <span>stop propagation flag</span> is unset.
     <li>
      <p>If <var title>event</var>'s <span>bubble flag</span> is set run
      these substeps:</p>
      <ol>
       <li><p>Reverse the order of <var title>event path</var>.
       <li><p>Set <var title>event</var>'s <span title=concept-event-phase>phase</span> to <span title=dom-Event-BUBBLING_PHASE>BUBBLING_PHASE</span>.
       <li><p>For each object in the <var title>event path</var>
       <span title=concept-event-listener-invoke>invoke</span> its
       <span title=concept-event-listener>event listeners</span>, as long as
       <var title>event</var>'s <span>stop propagation flag</span> is unset.
      </ol>
    </ol>
   </dd>
   <dt>Otherwise
   <dd><p><span title=concept-event-listener-invoke>Invoke</span> the
   <span title=concept-event-listener>event listeners</span> of
   <var title>event</var>'s <span title=concept-event-target>target</span>.
  </dl>
  <!-- XXX This could be flattened by just letting "event path" be empty for
           objects not participating in a tree. -->
 </li>
 <li><p>Unset <var title>event</var>'s <span>dispatch flag</span>.
 <li><p>Set <var title>event</var>'s <span title=concept-event-phase>phase</span> to <span title=dom-Event-AT_TARGET>AT_TARGET</span>.
 <li><p>Set <var title>event</var>'s <span title=concept-event-current-target>current target</span> to null.
 <li><p>Return false if <var title>event</var>'s <span>canceled flag</span>
 is set and true otherwise.
</ol>


<p>To <dfn title=concept-event-listener-invoke>invoke</dfn> the <span title=concept-event-listener>event listeners</span> for an object run these steps:</p>
<ol>
 <li><p>Let <var title>event</var> be the <span title=concept-event>event</span>
 for which the <span title=concept-event-listener>event listeners</span> are
 invoked.
 <li><p>Let <var title>listeners</var> be a static list of the
 <span title=concept-event-listener>event listeners</span> associated with
 the object for which these steps are run.
 <li><p>Set <var title>event</var>'s
 <span title=concept-event-current-target>current target</span> to the
 object for which these steps are run.
 <li>
  <p>Then run these substeps for each
  <span title=concept-event-listener>event listener</span> in
  <var title>listeners</var>:</p>
  <ol>
   <li><p>If <var title>event</var>'s
   <span>stop immediate propagation flag</span> is set, terminate the
   <span title=concept-event-listener-invoke>invoke</span> algorithm.
   <li><p>Let <var title>listener</var> be the
   <span title=concept-event-listener>event listener</span>.
   <li><p>If <var title>event</var>'s
   <span title=concept-event-type>type</span> is not
   <var title>listener</var>'s <b>name</b>, terminate these substeps (and
   run them for the next
   <span title=concept-event-listener>event listener</span>).
   <li><p>If <var title>event</var>'s
   <span title=concept-event-phase>phase</span> is
   <span title=dom-Event-CAPTURING_PHASE>CAPTURING_PHASE</span> and
   <var title>listener</var>'s <b>capture</b> is false, terminate these
   substeps (and run them for the next
   <span title=concept-event-listener>event listener</span>).
   <li><p>If <var title>event</var>'s
   <span title=concept-event-phase>phase</span> is
   <span title=dom-Event-BUBBLING_PHASE>BUBBLING_PHASE</span> and
   <var title>listener</var>'s <b>capture</b> is true, terminate these
   substeps (and run them for the next
   <span title=concept-event-listener>event listener</span>).
   <li><p>Run <var title>listener</var>'s <b>listener</b>.
  </ol>
 </li>
</ol>


<h3>Firing Events</h3>
<p>To
<dfn title=concept-event-fire>fire an event named <var title>e</var></dfn>
means that an <span title=concept-event>event</span> using the
<code>Event</code> interface, with its
<span title=concept-event-type>type</span> set to <var title>e</var>, and
its <span>trusted flag</span> set, is to be
<span title=concept-event-dispatch>dispatched</span> at the indicated
object.</p>

<p class=note>Fire is short for initializing and
<span title=concept-event-dispatch>dispatching</span> an
<span title=concept-event>event</span>.

<p class=note><span title=concept-event-fire>Fire an event</span> is a
concept to make initializing and
<span title=concept-event-dispatch>dispatching</span> an
<span title=concept-event>event</span> easier to write down. If the
<span title=concept-event>event</span> needs its <span>bubble flag</span> or
<span>cancel flag</span> set, one would write e.g.
"<span title=concept-event-fire>fire an event</span> named
<code title>submit</code></span> with its <span>cancel flag</span> set".


<h3>Mutation events</h3>
<p class=XXX>The status of mutation events is currently unclear. The editors
hope they can eventually be removed from the platform. There is
<a href=http://lists.w3.org/Archives/Public/public-webapps/2009AprJun/0745.html>a proposal</a>
for a replacement. We encourage experimentation with that proposal, as well as
alternative proposals.



<h2>Nodes</h2>
<h3>Nodes Model</h3>

<p><code>Node</code> objects (simply called
<dfn title=concept-node>nodes</dfn>)
<span title=concept-tree-participate>participate</span> in a
<span title=concept-tree>tree</span>.

<p>The <span title=concept-tree>tree</span> of
<span title=concept-node>nodes</span> is constrained as follows, expressed
as a relationship between the type of <span title=concept-node>node</span>
and its allowed <span title=concept-tree-child>children</span>:
<dl>
 <dt><code>Document</code>
 <dd>
  <p>In <span>tree order</span>:
  <ol>
   <li><p>Zero or more nodes each of which is either
   <code>ProcessingInstruction</code> or <code>Comment</code>.
   <li><p>Optionally one <code>DocumentType</code> node.
   <li><p>Zero or more nodes each of which is either
   <code>ProcessingInstruction</code> or <code>Comment</code>.
   <li><p>Optionally one <code>Element</code> node.
   <li><p>Zero or more nodes each of which is either
   <code>ProcessingInstruction</code> or <code>Comment</code>.
  </ol>
 <dt><code>DocumentFragment</code>
 <dt><code>Element</code>
 <dd><p>Zero or more nodes each of which is one of <code>Element</code>,
 <code>ProcessingInstruction</code>, <code>Comment</code>, or
 <code>Text</code>.
 <dt><code>DocumentType</code>
 <dt><code>ProcessingInstruction</code>
 <dt><code>Comment</code>
 <dt><code>Text</code>
 <dd><p>None.
</dl>

<p>A <span title=concept-node>node</span>, or its
<span title=concept-tree-child>children</span> in case of a
<code>DocumentFragment</code> object, are said to
<dfn>violate the node hierarchy</dfn> of another
<span title=concept-node>node</span> if inserting them within the other
<span title=concept-node>node</span>'s <span title=concept-tree>tree</span>
would violate the constraints listed above.

<p class="note">Operations that would cause a node to
<span>violate the node hierarchy</span> of another node will throw a
<code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>.

<p class=XXX>The normative requirements to make this note true are not yet in
place.

<!--AttrExodus -->

<!-- XXXhierarchy - make sure to expand DocumentFragment before checking -->


<h3>Cloning nodes</h3>
<p>Specifications may define <dfn title=concept-clone-ext>cloning steps</dfn>
for all or some <span title=concept-node>nodes</span>.

<p>To <dfn>clone</dfn> a <var title>node</var>, with a
<var title>new ownerDocument</var> and with a
<dfn><i>clone children flag</i></dfn>, these steps must be run:

<ol>
 <li><p>If <var title>node</var> is a <code>Document</code> or
 <code>DocumentType</code> node, throw a
 <code title=dom-DOMException-DATA_CLONE_ERR>DATA_CLONE_ERR</code> exception
 and terminate these steps. <!--XXX wrong? -->

 <li>
  <p>Let <var title>copy</var> be a new <code>Node</code> that implements the same interfaces as <var title>node</var>, with <code title=dom-Node-ownerDocument>ownerDocument</code> set to
  <var title>new ownerDocument</var>. Also copy the following, depending on the
  <var title>node</var>:
  <dl class=switch>
   <dt><code>Element</code>
   <dd><p>Its <span title=concept-element-namespace>namespace</span>,
   <span title=concept-element-namespace-prefix>namespace prefix</span>,
   <span title=concept-element-local-name>local name</span>, and its
   associated collection of <code>Attr</code> objects.

   <!--AttrExodus
   <dt><code>Attr</code>
   <dd><p><code title=dom-Attr-value>value</code>
   -->

   <dt><code>Text</code>
   <dt><code>Comment</code>
   <dd><p>Its <code title=dom-CharacterData-data>data</code>.

   <dt><code>ProcessingInstruction</code>

   <dd><p>Its <span title=concept-PI-target>target</span> and
   <span title=concept-PI-data>data</span>.

   <dt>Any other node
   <dd><p>&mdash;
  </dl>

 <li><p>Run any <span title=concept-clone-ext>cloning steps</span> defined for
 <var title>node</var> in <span>other applicable specifications</span>.

 <li><p>If the <i>clone children flag</i> is set, <span>clone</span> all the children of <var title>node</var> and append them to <var title>copy</var>, with the same <var title>new ownerDocument</var> and the <i>clone children flag</i> being set.

 <li><p>Return <var title>copy</var>.
</ol>


<h3>Interface <code>Node</code></h3>
<pre class=idl>interface <dfn>Node</dfn> : <span>EventTarget</span> {
  const unsigned short <span title=dom-Node-ELEMENT_NODE>ELEMENT_NODE</span> = 1;
  const unsigned short <span title=dom-Node-ATTRIBUTE_NODE>ATTRIBUTE_NODE</span> = 2; // historical
  const unsigned short <span title=dom-Node-TEXT_NODE>TEXT_NODE</span> = 3;
  const unsigned short <span title=dom-Node-CDATA_SECTION_NODE>CDATA_SECTION_NODE</span> = 4; // historical
  const unsigned short <span title=dom-Node-ENTITY_REFERENCE_NODE>ENTITY_REFERENCE_NODE</span> = 5; // historical
  const unsigned short <span title=dom-Node-ENTITY_NODE>ENTITY_NODE</span> = 6; // historical
  const unsigned short <span title=dom-Node-PROCESSING_INSTRUCTION_NODE>PROCESSING_INSTRUCTION_NODE</span> = 7;
  const unsigned short <span title=dom-Node-COMMENT_NODE>COMMENT_NODE</span> = 8;
  const unsigned short <span title=dom-Node-DOCUMENT_NODE>DOCUMENT_NODE</span> = 9;
  const unsigned short <span title=dom-Node-DOCUMENT_TYPE_NODE>DOCUMENT_TYPE_NODE</span> = 10;
  const unsigned short <span title=dom-Node-DOCUMENT_FRAGMENT_NODE>DOCUMENT_FRAGMENT_NODE</span> = 11;
  const unsigned short <span title=dom-Node-NOTATION_NODE>NOTATION_NODE</span> = 12; // historical
  readonly attribute unsigned short <span title=dom-Node-nodeType>nodeType</span>;<!-- NodeExodus

  readonly attribute DOMString <span title=dom-Node-namespaceURI>namespaceURI</span>;
  readonly attribute DOMString <span title=dom-Node-prefix>prefix</span>;
  readonly attribute DOMString <span title=dom-Node-localName>localName</span>;-->
  readonly attribute DOMString <span title=dom-Node-nodeName>nodeName</span>;

  readonly attribute DOMString <span title=dom-Node-baseURI>baseURI</span>;

  <!--AttrExodus
  boolean <span title=dom-Node-hasAttributes>hasAttributes</span>();
  readonly attribute <span>NamedNodeMap</span> <span title=dom-Node-attributes>attributes</span>;

  -->readonly attribute <span>Document</span> <span title=dom-Node-ownerDocument>ownerDocument</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-parentNode>parentNode</span>;
  readonly attribute <span>Element</span> <span title=dom-Node-parentElement>parentElement</span>;
  boolean <span title=dom-Node-hasChildNodes>hasChildNodes</span>();
  readonly attribute <span>NodeList</span> <span title=dom-Node-childNodes>childNodes</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-firstChild>firstChild</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-lastChild>lastChild</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-previousSibling>previousSibling</span>;
  readonly attribute <span>Node</span> <span title=dom-Node-nextSibling>nextSibling</span>;

  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_DISCONNECTED>DOCUMENT_POSITION_DISCONNECTED</span> = 0x01;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_PRECEDING>DOCUMENT_POSITION_PRECEDING</span> = 0x02;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_FOLLOWING>DOCUMENT_POSITION_FOLLOWING</span> = 0x04;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_CONTAINS>DOCUMENT_POSITION_CONTAINS</span> = 0x08;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_CONTAINED_BY>DOCUMENT_POSITION_CONTAINED_BY</span> = 0x10;
  const unsigned short <span title=dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</span> = 0x20;
  unsigned short <span title=dom-Node-compareDocumentPosition>compareDocumentPosition</span>(<span>Node</span> <var title>other</var>);

           attribute DOMString <span title=dom-Node-nodeValue>nodeValue</span>;
           attribute DOMString <span title=dom-Node-textContent>textContent</span>;
  <span>Node</span> <span title=dom-Node-insertBefore>insertBefore</span>([NoNull] <span>Node</span> <var title>newChild</var>, <span>Node</span> <var title>refChild</var>);
  <span>Node</span> <span title=dom-Node-replaceChild>replaceChild</span>([NoNull] <span>Node</span> <var title>newChild</var>, [NoNull] <span>Node</span> <var title>oldChild</var>);
  <span>Node</span> <span title=dom-Node-removeChild>removeChild</span>([NoNull] <span>Node</span> <var title>oldChild</var>);
  <span>Node</span> <span title=dom-Node-appendChild>appendChild</span>([NoNull] <span>Node</span> <var title>newChild</var>);<!--
  void normalize();-->

  <span>Node</span> <span title=dom-Node-cloneNode>cloneNode</span>(boolean <var title>deep</var>);
  boolean <span title=dom-Node-isSameNode>isSameNode</span>(<span>Node</span> <var title>node</var>);
  boolean <span title=dom-Node-isEqualNode>isEqualNode</span>(<span>Node</span> <var title>node</var>);

  DOMString <span title=dom-Node-lookupPrefix>lookupPrefix</span>([TreatNullAs=EmptyString] DOMString <var title>namespace</var>);
  DOMString <span title=dom-Node-lookupNamespaceURI>lookupNamespaceURI</span>(DOMString? <var title>prefix</var>);
  boolean <span title=dom-Node-isDefaultNamespace>isDefaultNamespace</span>([TreatNullAs=EmptyString] DOMString <var title>namespace</var>);<!--
  DOMObject getFeature(DOMString feature, DOMString version);
  DOMUserData setUserData(DOMString key, DOMUserData data, UserDataHandler handler);
  DOMUserData getUserData(DOMString key);-->
};</pre>

<p>The <dfn title=dom-Node-nodeType><code>nodeType</code></dfn> attribute
must return the type of the node, which must be one of the following:

<ul>
 <li><dfn title=dom-Node-ELEMENT_NODE><code>ELEMENT_NODE</code></dfn> (1);

 <li><dfn title=dom-Node-ATTRIBUTE_NODE><code>ATTRIBUTE_NODE</code></dfn> (2, historical);

 <li><dfn title=dom-Node-TEXT_NODE><code>TEXT_NODE</code></dfn> (3);

 <li><dfn title=dom-Node-CDATA_SECTION_NODE><code>CDATA_SECTION_NODE</code></dfn> (4, historical);

 <li><dfn title=dom-Node-ENTITY_REFERENCE_NODE><code>ENTITY_REFERENCE_NODE</code></dfn> (5, historical);

 <li><dfn title=dom-Node-ENTITY_NODE><code>ENTITY_NODE</code></dfn> (6, historical);

 <li><dfn title=dom-Node-PROCESSING_INSTRUCTION_NODE><code>PROCESSING_INSTRUCTION_NODE</code></dfn> (7);

 <li><dfn title=dom-Node-COMMENT_NODE><code>COMMENT_NODE</code></dfn> (8);

 <li><dfn title=dom-Node-DOCUMENT_NODE><code>DOCUMENT_NODE</code></dfn> (9);

 <li><dfn title=dom-Node-DOCUMENT_TYPE_NODE><code>DOCUMENT_TYPE_NODE</code></dfn> (10);

 <li><dfn title=dom-Node-DOCUMENT_FRAGMENT_NODE><code>DOCUMENT_FRAGMENT_NODE</code></dfn> (11);

 <li><dfn title=dom-Node-NOTATION_NODE><code>NOTATION_NODE</code></dfn> (12, historical).
</ul>

<p class=note>The constants marked historical can no longer be returned, but
are still exposed on the interface.

<!-- NodeExodus
<hr>

<p>The <dfn title=dom-Node-namespaceURI><code>namespaceURI</code></dfn> attribute must return the namespace that is associated with the node, if there is one and it's not the empty string, or null otherwise.

<p>The <dfn title=dom-Node-prefix><code>prefix</code></dfn> attribute must return the prefix that is associated with the node, if there is one and it's not the empty string, or null otherwise.
<!- - support setting? - - On setting, it must run the following steps:

<ol>
 <li><p>Let <var title>prefix</var> be the value being assigned.
 <li>
  <p>If <var title>prefix</var> is not null, run the following substeps:
  <ol>
   <li><p>If <var title>prefix</var> does not match the
   <code data-anolis-spec=xml>Name</code> production in XML, throw an
   <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
   exception and terminate these steps.
   <li><p>If <var title>prefix</var> does not match the <code
   data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, throw a
   <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and
   terminate these steps.
  </ol>
 <li><p>Actually this does not match any browser. Let's try to drop it instead.
</ol>- ->

<p>The <dfn title=dom-Node-localName><code>localName</code></dfn> attribute
must return the local name that is associated with the node, if it has one,
and null otherwise.-->

<p>The <dfn title=dom-Node-nodeName><code>nodeName</code></dfn> attribute
must return the following, depending on the <span>context object</span>:

<dl class=switch>
 <dt><code>Element</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-Element-tagName>tagName</code> attribute.

 <!--AttrExodus
 <dt><code>Attr</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-Attr-name>name</code> attribute.
 -->

 <dt><code>Text</code>
 <dd><p>"<code title>#text</code>".

 <dt><code>ProcessingInstruction</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-ProcessingInstruction-target>target</code> attribute.

 <dt><code>Comment</code>
 <dd><p>"<code title>#comment</code>".

 <dt><code>Document</code>
 <dd><p>"<code title>#document</code>".

 <dt><code>DocumentType</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-DocumentType-name>name</code> attribute.

 <dt><code>DocumentFragment</code>
 <dd><p>"<code title>#document-fragment</code>".
</dl>

<hr>

<p>The <dfn title=dom-Node-baseURI><code>baseURI</code></dfn> attribute must <span class=XXX title>...</span>

<!--AttrExodus
<hr>

<p>The <dfn title=dom-Node-hasAttributes><code>hasAttributes()</code></dfn>
method must return true if there are any attributes associated with the
<span>context object</span>, if it is an <code>Element</code> node, and false
otherwise.

<p>The <dfn title=dom-Node-attributes><code>attributes</code></dfn> attribute must return a <code>NamedNodeMap</code> of all the <code>Attr</code> nodes associated with the node of the <span>context object</span>, if it is an <code>Element</code> node, or null otherwise.
-->

<hr>

<dl class=domintro>
 <dt><var title>doc</var> = <var title>node</var> .
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <dd>
  <p>Returns the <code>Document</code> <var title>node</var> belongs to.

 <dt><var title>parent</var> = <var title>node</var> .
 <code title=dom-Node-parentNode>parentNode</code>
 <dd>
  <p>Returns the parent node of <var title>node</var>.

 <dt><var title>parent</var> = <var title>node</var> .
 <code title=dom-Node-parentElement>parentElement</code>
 <dd>
  <p>Returns the parent node of <var title>node</var>, if it is an
  <code>Element</code>.

 <dt><var title>haschildren</var> = <var title>node</var> .
 <code title=dom-Node-hasChildNodes>hasChildNodes</code>
 <dd>
  <p>Returns whether <var title>node</var> has children.

 <dt><var title>children</var> = <var title>node</var> .
 <code title=dom-Node-childNodes>childNodes</code>
 <dd>
  <p>Returns the children of <var title>node</var>.

 <dt><var title>child</var> = <var title>node</var> .
 <code title=dom-Node-firstChild>firstChild</code>
 <dd>
  <p>Returns the first child of <var title>node</var>.

 <dt><var title>child</var> = <var title>node</var> .
 <code title=dom-Node-lastChild>lastChild</code>
 <dd>
  <p>Returns the last child of <var title>node</var>.

 <dt><var title>child</var> = <var title>node</var> .
 <code title=dom-Node-previousSibling>previousSibling</code>
 <dd>
  <p>Returns the node before <var title>node</var> in its parent.

 <dt><var title>child</var> = <var title>node</var> .
 <code title=dom-Node-nextSibling>nextSibling</code>
 <dd>
  <p>Returns the node after <var title>node</var> in its parent.
</dl>

<div class=impl>

<p>The <dfn title=dom-Node-ownerDocument><code>ownerDocument</code></dfn> attribute must return the <code>Document</code> node that the <span>context object</span> is associated with, or null if there is none.

<p>The <dfn title=dom-Node-parentNode><code>parentNode</code></dfn>
attribute must return the <span title=concept-tree-parent>parent</span>.
<!-- AttrExodus
<li><p>If the <span>context object</span> is an <code>Attr</code> node,
return null and terminate these steps.
-->

<!-- XXX needed? Minefield does not have this -->
<p>The <dfn title=dom-Node-parentElement><code>parentElement</code></dfn>
attribute must return the <span>parent element</span>.

<p>The <dfn title=dom-Node-hasChildNodes><code>hasChildNodes()</code></dfn>
method must return false if the <span>context object</span> has no
<span title=concept-tree-child>children</span>, or true otherwise.

<p>The <dfn title=dom-Node-childNodes><code>childNodes</code></dfn>
attribute must return a <code>NodeList</code> rooted at the
<span>context object</span> matching only
<span title=concept-tree-child>children</span>.

<p>The <dfn title=dom-Node-firstChild><code>firstChild</code></dfn> attribute must return the first <span title=concept-tree-child>child</span>
of the <span>context object</span>, or null if there is none.

<p>The <dfn title=dom-Node-lastChild><code>lastChild</code></dfn> attribute must return the last <span title=concept-tree-child>child</span> of the
<span>context object</span>, or null if there is none.

<p>The
<dfn title=dom-Node-previousSibling><code>previousSibling</code></dfn>
attribute must return the first
<span title=concept-tree-previous-sibling>previous sibling</span> of the
<span>context object</span>, or null if there is none.
<!-- AttrExodus
 <li><p>If the <span>context object</span> is an <code>Attr</code> node,
 return null and terminate these steps.
-->

<p>The <dfn title=dom-Node-nextSibling><code>nextSibling</code></dfn> attribute must return the  first
<span title=concept-tree-next-sibling>next sibling</span> of the
<span>context object</span>, or null if there is none.
<!-- AttrExodus
 <li><p>If the <span>context object</span> is an <code>Attr</code> node,
 return null and terminate these steps.
-->

</div>

<hr>

<p>These are the constants
<code title=dom-Node-compareDocumentPosition>compareDocumentPosition()</code>
returns.

<ul>
 <li><dfn title=dom-Node-DOCUMENT_POSITION_DISCONNECTED><code>DOCUMENT_POSITION_DISCONNECTED</code></dfn> (1);

 <li><dfn title=dom-Node-DOCUMENT_POSITION_PRECEDING><code>DOCUMENT_POSITION_PRECEDING</code></dfn> (2);

 <li><dfn title=dom-Node-DOCUMENT_POSITION_FOLLOWING><code>DOCUMENT_POSITION_FOLLOWING</code></dfn> (4);

 <li><dfn title=dom-Node-DOCUMENT_POSITION_CONTAINS><code>DOCUMENT_POSITION_CONTAINS</code></dfn> (8);

 <li><dfn title=dom-Node-DOCUMENT_POSITION_CONTAINED_BY><code>DOCUMENT_POSITION_CONTAINED_BY</code></dfn> (16);

 <li><dfn title=dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC><code>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></dfn> (32).
</ul>

<p>The <dfn
title=dom-Node-compareDocumentPosition><code>compareDocumentPosition(<var
title>other</var>)</code></dfn> method must <span class=XXX title>...</span>
<!-- XXX @beverloo might figure this out; remove impl specific? -->

<hr>

<p>The <dfn title=dom-Node-nodeValue><code>nodeValue</code></dfn> attribute
must return the following, depending on the <span>context object</span>:

<dl class=switch>
 <!--AttrExodus <dt><code>Attr</code> -->
 <dt><code>Text</code>
 <dt><code>Comment</code>
 <dt><code>ProcessingInstruction</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-Node-textContent>textContent</code> attribute.

 <dt>Any other node
 <dd><p>Null.
</dl>

<p>Setting the <code title=dom-Node-nodeValue>nodeValue</code> attribute
must do as described below, depending on the <span>context object</span>:

<dl class=switch>
 <!--AttrExodus <dt><code>Attr</code> -->
 <dt><code>Text</code>
 <dt><code>Comment</code>
 <dt><code>ProcessingInstruction</code>
 <dd><p>Set the <span>context object</span>'s
 <code title=dom-Node-textContent>textContent</code> attribute to the given
 value.

 <dt>Any other node
 <dd><p>Do nothing.
</dl>

<p>The <dfn title=dom-Node-textContent><code>textContent</code></dfn>
attribute must return the following, depending on the
<span>context object</span>:

<dl class=switch>
 <dt><code>DocumentFragment</code>
 <dt><code>Element</code>
 <!--AttrExodus <dt><code>Attr</code> -->
 <dd><p>The concatenation of the
 <code title=dom-CharacterData-data>data</code> attributes of all the
 <code>Text</code> object
 <span title=concept-tree-descendant>descendants</span> of the
 <span>context object</span>, in <span>tree order</span>.

 <dt><code>Text</code>
 <dt><code>Comment</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-CharacterData-data>data</code> attribute.

 <dt><code>ProcessingInstruction</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-ProcessingInstruction-data>data</code> attribute.

 <dt>Any other node
 <dd>Null.
</dl>

<p>Setting the <code title=dom-Node-textContent>textContent</code>
attribute must do as described below, depending on the
<span>context object</span>:

<dl class=switch>
 <dt><code>DocumentFragment</code>
 <dt><code>Element</code>
 <!--AttrExodus <dt><code>Attr</code> -->
 <dd>
  <ol>
   <li><p>Remove all the
   <span title=concept-tree-descendant>descendants</span> of the <span>context object</span>.
   <li><p>Let <var title>data</var> be the given value.
   <li><p>If <var title>data</var> is not the empty string, append a new
   <code>Text</code> node to the <span>context object</span> whose
   <code title=dom-CharacterData-data>data</code> is set to <var title>data</var>.
  </ol>

 <dt><code>Text</code>
 <dt><code>Comment</code>
 <dd><p>Set <span>context object</span>'s
 <code title=dom-CharacterData-data>data</code> attribute to the given
 value.

 <dt><code>ProcessingInstruction</code>
 <dd><p>Set the <span>context object</span>'s
 <code title=dom-ProcessingInstruction-data>data</code> attribute to the
 given value.

 <dt>Any other node
 <dd>Do nothing.
</dl>

<p>The
<dfn title=dom-Node-insertBefore><code>insertBefore(<var title>newChild</var>, <var title>refChild</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If the <span>context object</span> is not a <code>Document</code>,
 <code>DocumentFragment</code> or <code>Element</code>, throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <li><p>If <var title>refChild</var> is null, return the result of invoking
 <span>context object</span>'s
 <code title=dom-Node-appendChild>appendChild</code> with
 <var title>newChild</var> as argument and terminate these steps.

 <li><p>If <var title>refChild</var> is not a child of the
 <span>context object</span>, then throw a
 <code title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</code> exception
 and terminate these steps.

 <li><p>If <var title>newChild</var> is the <span>context object</span> or an
 <span title=concept-tree-ancestor>ancestor</span> of the
 <span>context object</span> throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <!-- XXXhierarchy -->

 <li><p>If <var title>newChild</var> is a <code>DocumentType</code> node and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is not null throw a
 <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>newChild</var> is a <code>DocumentType</code> node set its
 <code title=dom-Node-ownerDocument>ownerDocument</code> to the
 <span>context object</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>.

 <li><p>If <var title>newChild</var> is not a <code>DocumentType</code> node let
 <var title>newChild</var> be the result of invoking the
 <span>context object</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <code title=dom-Document-adoptNode>adoptNode</code> method with
 <var title>newChild</var> as its argument.

 <li><p>If <var title>newChild</var> is a <code>DocumentFragment</code> node,
 insert the children of <var title>newChild</var> in the
 <span>context object</span>, in <span>tree order</span>, so that the last
 child becomes the previous sibling of <var title>refChild</var>.

 <li><p>Otherwise insert <var title>newChild</var> in the
 <span>context object</span> as the previous sibling of <var title>refChild</var>.

 <li><p>Return <var title>newChild</var>.
</ol>

<p>The
<dfn title=dom-Node-replaceChild><code>replaceChild(<var title>newChild</var>, <var title>oldChild</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If the <span>context object</span> is not a <code>Document</code>,
 <code>DocumentFragment</code> or <code>Element</code>, throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <li><p>If <var title>oldChild</var> is not a child of the
 <span>context object</span>, then throw a
 <code title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</code> exception
 and terminate these steps.

 <li><p>If <var title>newChild</var> is the <span>context object</span> or an
 <span title=concept-tree-ancestor>ancestor</span> of the
 <span>context object</span> throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <!-- XXXhierarchy -->

 <li><p>If <var title>newChild</var> is a <code>DocumentType</code> node and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is not null throw a
 <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>newChild</var> is a <code>DocumentType</code> node set its
 <code title=dom-Node-ownerDocument>ownerDocument</code> to the
 <span>context object</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>.

 <li><p>If <var title>newChild</var> is not a <code>DocumentType</code> node let
 <var title>newChild</var> be the result of invoking the
 <span>context object</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <code title=dom-Document-adoptNode>adoptNode</code> method with
 <var title>newChild</var> as its argument.

 <li><p>Let <var title>refChild</var> be <var title>oldChild</var>'s
 first <span title=concept-tree-next-sibling>next sibling</span>.

 <li><p>Remove <var title>oldChild</var> from the <span>context object</span>.

 <li><p>Return the result of invoking the <span>context object</span>'s
 <code title=dom-Node-insertBefore>insertBefore</code> method with
 <var title>newChild</var> and <var title>refChild</var> as arguments.
</ol>

<p>The
<dfn
title=dom-Node-removeChild><code>removeChild(<var title>oldChild</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If the <span>context object</span> is not a <code>Document</code>,
 <code>DocumentFragment</code> or <code>Element</code>, throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <li><p>If <var title>oldChild</var> is not a child of the
 <span>context object</span>, then throw a
 <code title=dom-DOMException-NOT_FOUND_ERR>NOT_FOUND_ERR</code> exception
 and terminate these steps.
 <!-- Including other documents. -->

 <li><p>Remove <var title>oldChild</var> from the <span>context object</span>.

 <li><p>Return <var title>oldChild</var>.
</ol>

<p>The
<dfn
title=dom-Node-appendChild><code>appendChild(<var title>newChild</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If the <span>context object</span> is not a <code>Document</code>,
 <code>DocumentFragment</code> or <code>Element</code>, throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <li><p>If <var title>newChild</var> is the <span>context object</span> or an
 <span title=concept-tree-ancestor>ancestor</span> of the
 <span>context object</span> throw a
 <code title=dom-DOMException-HIERARCHY_REQUEST_ERR>HIERARCHY_REQUEST_ERR</code>
 and terminate these steps.

 <!-- XXXhierarchy -->

 <li><p>If <var title>newChild</var> is a <code>DocumentType</code> node and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is not null throw a
 <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>newChild</var> is a <code>DocumentType</code> node set its
 <code title=dom-Node-ownerDocument>ownerDocument</code> to the
 <span>context object</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>.

 <li><p>If <var title>newChild</var> is not a <code>DocumentType</code> node let
 <var title>newChild</var> be the result of invoking the
 <span>context object</span>'s
 <code title=dom-Node-ownerDocument>ownerDocument</code>
 <code title=dom-Document-adoptNode>adoptNode</code> method with
 <var title>newChild</var> as its argument.

 <li><p>Append <var title>newChild</var> to the <span>context object</span>.

 <li><p>Return <var title>newChild</var>.
</ol>

<hr>

<dl class=domintro>
 <dt><var title>new node</var> = <var title>node</var> .
 <code title=dom-Node-cloneNode>cloneNode</code>(<var title>deep</var>)
 <dd>
  <p>Returns a copy of the node, with its relevant node-specific data. If
  <var title>deep</var> is true, the copy also includes the node's children.

 <dt><var title>same</var> = <var title>node</var> .
 <code title=dom-Node-isSameNode>isSameNode</code>(<var title>other</var>)
 <dd>
  <p>Returns whether <var title>node</var> and <var title>other</var> are the
  exact same node.

 <dt><var title>similar</var> = <var title>node</var> .
 <code title=dom-Node-isEqualNode>isEqualNode</code>(<var title>other</var>)
 <dd>
  <p>Returns whether <var title>node</var> and <var title>other</var> have the
  same properties.
</dl>

<div class=impl>

<p>The
<dfn title=dom-Node-cloneNode><code>cloneNode(<var title>deep</var>)</code></dfn>
method must return a <span>clone</span> of the <span>context object</span>,
with <var title>new ownerDocument</var> being the <span>context object</span>'s
<code title=dom-Node-ownerDocument>ownerDocument</code>, and the
<i>clone children flag</i> set if <var title>deep</var> is true.

<p>The
<dfn title=dom-Node-isSameNode><code>isSameNode(<var title>node</var>)</code></dfn>
method must return true if <var title>node</var> is a reference to the same
object as the <span>context object</span>, and false otherwise.

<p>The
<dfn title=dom-Node-isEqualNode><code>isEqualNode(<var title>node</var>)</code></dfn>
method must return true if all of the following conditions are true, and
false otherwise:

<ul>
 <li><p><var title>node</var> is not null.
 <li><p><var title>node</var>'s <code title=dom-Node-nodeType>nodeType</code> is the same as the <span>context object</span>'s <code title=dom-Node-nodeType>nodeType</code>.
 <li><p><var title>node</var>'s <code title=dom-Node-nodeName>nodeName</code> is the same as the <span>context object</span>'s <code title=dom-Node-nodeName>nodeName</code>.
 <li><p><var title>node</var>'s <code title=dom-Node-nodeValue>nodeValue</code> is the same as the <span>context object</span>'s <code title=dom-Node-nodeValue>nodeValue</code>.
 <li>
  <p>The following are also equal, depending on <var title>node</var>:
  <dl class=switch>
   <dt><code>DocumentType</code>
   <dd><p>Its <span title=concept-doctype-name>name</span>,
   <span title=concept-doctype-publicid>public ID</span>, and
   <span title=concept-doctype-systemid>system ID</span>.

   <dt><code>Element</code>
   <dd><p>Its <span title=concept-element-namespace>namespace</span>,
   <span title=concept-element-namespace-prefix>namespace prefix</span>,
   <span title=concept-element-local-name>local name</span>, and its
   associated collection of <code>Attr</code> objects. <!-- XXX def -->

   <!--AttrExodus
   <dt><code>Attr</code>
   <dd><p><code title=dom-Attr-value>value</code>
   -->

   <dt><code>Text</code>
   <dt><code>Comment</code>
   <dd><p>Its <code title=dom-CharacterData-data>data</code>.

   <dt><code>ProcessingInstruction</code>

   <dd><p>Its <span title=concept-PI-target>target</span> and
   <span title=concept-PI-data>data</span>.

   <dt>Any other node
   <dd><p>&mdash;
  </dl>
 <li><p><var title>node</var>'s <code title=dom-Node-childNodes>childNodes</code>' <code title=dom-NodeList-length>length</code> is the same as the <span>context object</span>'s <code title=dom-Node-childNodes>childNodes</code>' <code title=dom-NodeList-length>length</code>.
 <li><p>Calling <code title=dom-Node-isEqualNode>isEqualNode</code> on each child node of the <span>context object</span>, with the child node of the same index in <var title>node</var> as argument returns true for every child node.
</ul>

</div>

<hr>

<p>To <dfn>locate a namespace prefix</dfn> for an <var title>element</var> using
<var title>namespace</var> run these steps:

<ol>
 <li><p>If <var title>element</var>'s
 <span title=concept-element-namespace>namespace</span> is
 <var title>namespace</var> and its
 <span title=concept-element-namespace-prefix>namespace prefix</span> is not
 null return its
 <span title=concept-element-namespace-prefix>namespace prefix</span> and
 terminate these steps.

 <li><p>If, in <var title>element</var>'s
 <code title=dom-Element-attributes>attributes</code>, there is an
 <code>Attr</code> whose
 <span title=concept-attr-namespace-prefix>namespace prefix</span> is
 "<code title>xmlns</code>" and <span title=concept-attr-value>value</span>
 is <var title>namespace</var> then return its
 <span title=concept-attr-local-name>local name</span> and terminate these
 steps.

 <li><p>Return the result of running <span>locate a namespace prefix</span>
 on its <span>parent element</span> using <var title>namespace</var>, if
 that is not null, or null otherwise.
</ol>

<p>To <dfn>locate a namespace</dfn> for a <var title>node</var> using
<var title>prefix</var> depends on the <var title>node</var>:

<dl class=switch>
 <dt><code>Element</code>
 <dd>
  <ol>
   <li><p>If its <span title=concept-element-namespace>namespace</span> is
   not null and its
   <span title=concept-element-namespace-prefix>namespace prefix</span> is
   <var title>prefix</var> return
   <span title=concept-element-namespace>namespace</span> and terminate
   these steps.

   <li><p>If, in its <code title=dom-Element-attributes>attributes</code>, there
   is an <code>Attr</code>

   whose <span title=concept-attr-namespace-prefix>namespace prefix</span>
   is "<code title>xmlns</code>" and
   <span title=concept-attr-local-name>local name</span> is
   <var title>prefix</var> or

   whose <span title=concept-attr-namespace-prefix>namespace prefix</span>
   is null and <span title=concept-attr-local-name>local name</span> is
   "<code title>xmlns</code>":

    <ol>
     <li><p>Let <var title>value</var> be its
     <span title=concept-attr-value>value</span> if it is not the empty
     string, or null otherwise.

     <li><p>Return <var title>value</var> and terminate these steps.
    </ol>

   <li><p>Return the result of running <span>locate a namespace</span> on
   its <span>parent element</span> using <var title>prefix</var>, if that is
   not null, or null otherwise.
  </ol>

 <!--AttrExodus <code>Attr</code> -->
 <dt><code>Document</code>
 <dd><p>Return the result of running <span>locate a namespace</span> on its
 <code title=dom-Document-documentElement>documentElement</code> using
 <var title>prefix</var>, if
 <code title=dom-Document-documentElement>documentElement</code> is
 not null, or null otherwise.

 <dt><code>DocumentType</code>
 <dt><code>DocumentFragment</code>
 <dd><p>Return null.

 <dt>Any other node
 <dd><p>Return the result of running <span>locate a namespace</span> on its
 <span>parent element</span> using <var title>prefix</var>, if that is not
 null, or null otherwise.
</dl>

<p>The
<dfn title=dom-Node-lookupPrefix><code>lookupPrefix(<var title>namespace</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If <var title>namespace</var> is the empty string return null.

 <li>
  <p>Otherwise it depends on the <span>context object</span>:

  <dl class=switch>
   <dt><code>Element</code>
   <dd><p>Return the result of
   <span title="locate a namespace prefix">locating a namespace prefix</span>
   for the node using <var title>namespace</var>.

   <!--AttrExodus <code>Attr</code> -->
   <dt><code>Document</code>
   <dd><p>Return the result of
   <span title="locate a namespace prefix">locating a namespace prefix</span>
   for its <code title=dom-Document-documentElement>documentElement</code>, if
   that is not null, or null otherwise.

   <dt><code>DocumentType</code>
   <dt><code>DocumentFragment</code>
   <dd><p>Return null.

   <dt>Any other node
   <dd><p>Return the result of
   <span title="locate a namespace prefix">locating a namespace prefix</span>
   for its <span>parent element</span>, or if that is null, null.
  </dl>
</ol>

<p>The
<dfn title=dom-Node-lookupNamespaceURI><code>lookupNamespaceURI(<var title>prefix</var>)</code></dfn>
method must return the result of running <span>locate a namespace</span> for
the <span>context object</span> using <var title>prefix</var>.

<p>The
<dfn title=dom-Node-isDefaultNamespace><code>isDefaultNamespace(<var title>namespace</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>Let <var title>defaultNamespace</var> be the result of invoking
 <code title=dom-Node-lookupNamespaceURI>lookupNamespaceURI</code> with null
 as argument on the <span>context object</span>.

 <li><p>If <var title>defaultNamespace</var> is null let it be the empty
 string.

 <li><p>Return true if <var title>defaultNamespace</var> is <var title>namespace</var>,
 or false otherwise.
</ol>


<h3>Interface <code>DocumentFragment</code></h3>
<pre class=idl>interface <dfn>DocumentFragment</dfn> : <span>Node</span> {
};</pre>


<h3>Interface <code>Document</code></h3>
<pre class=idl>interface <dfn>Document</dfn> : <span>Node</span> {
  readonly attribute <span>DOMImplementation</span> <span title=dom-Document-implementation>implementation</span>;
           attribute DOMString <span title=dom-Document-documentURI>documentURI</span>;
  readonly attribute DOMString <span title=dom-Document-compatMode>compatMode</span>;

  readonly attribute <span>DocumentType</span> <span title=dom-Document-doctype>doctype</span>;
  readonly attribute <span>Element</span> <span title=dom-Document-documentElement>documentElement</span>;
  <span>NodeList</span> <span title=dom-Document-getElementsByTagName>getElementsByTagName</span>(DOMString <var title>qualifiedName</var>);
  <span>NodeList</span> <span title=dom-Document-getElementsByTagNameNS>getElementsByTagNameNS</span>(DOMString <var title>namespace</var>, DOMString <var title>localName</var>);
  <span>NodeList</span> <span title=dom-Document-getElementsByClassName>getElementsByClassName</span>(DOMString <var title>classNames</var>);
  <span>Element</span> <span title=dom-Document-getElementById>getElementById</span>(DOMString <var title>elementId</var>);

  <span>Element</span> <span title=dom-Document-createElement>createElement</span>([TreatNullAs=EmptyString] DOMString <var title>localName</var>);
  <span>Element</span> <span title=dom-Document-createElementNS>createElementNS</span>(DOMString <var title>namespace</var>, DOMString <var title>qualifiedName</var>);
  <span>DocumentFragment</span> <span title=dom-Document-createDocumentFragment>createDocumentFragment</span>();
  <span>Text</span> <span title=dom-Document-createTextNode>createTextNode</span>(DOMString <var title>data</var>);
  <span>Comment</span> <span title=dom-Document-createComment>createComment</span>(DOMString <var title>data</var>);
  <span>ProcessingInstruction</span> <span title=dom-Document-createProcessingInstruction>createProcessingInstruction</span>(DOMString <var title>target</var>, DOMString <var title>data</var>);<!--
  CDATASection createCDATASection(DOMString data);
  EntityReference createEntityReference(DOMString name);
  <span>Attr</span> <span title=dom-Document-createAttribute>createAttribute</span>(DOMString name);
  <span>Attr</span> <span title=dom-Document-createAttributeNS>createAttributeNS</span>(DOMString namespace, DOMString qualifiedName);
    If adding this, search for [createAttribute]-->

  <span>Node</span> <span title=dom-Document-importNode>importNode</span>(<span>Node</span> <var title>node</var>, boolean <var title>deep</var>);
  <span>Node</span> <span title=dom-Document-adoptNode>adoptNode</span>(<span>Node</span> <var title>node</var>);<!--
  readonly attribute DOMString xmlEncoding;
           attribute boolean xmlStandalone;
           attribute DOMString <span title=dom-Document-xmlVersion>xmlVersion</span>;
           attribute boolean strictErrorChecking;
  readonly attribute DOMConfiguration domConfig;
  void normalizeDocument();
  Node renameNode(Node n, DOMString namespace, DOMString qualifiedName);-->

  <span>Event</span> <span title=dom-Document-createEvent>createEvent</span>(DOMString <var title>interface</var>);
};</pre>

<p>A <code>Document</code> node is assumed to be an <dfn>XML document</dfn>
unless it is flagged as being an <dfn>HTML document</dfn>. Whether a
document is an <span>HTML document</span> or an <span>XML document</span>
affects the behavior of certain APIs.

<p>A <code>Document</code> node is always set to one of three modes:
<dfn title=concept-no-quirks-mode>no-quirks mode</dfn>, the default;
<dfn title=concept-quirks-mode>quirks mode</dfn>, used typically for legacy
documents; and
<dfn title=concept-limited-quirks-mode>limited-quirks mode</dfn>, also known
as "almost standards" mode. Unless
<span>other applicable specifications</span> define otherwise, the
<code>Document</code> must be in
<span title=concept-no-quirks-mode>no-quirks mode</span>.

<p class=note>The mode is only ever changed from the default if the
<code>Document</code> node is created by the
<span data-anolis-spec=html>HTML parser</span>, based on the presence,
absence, or value of the DOCTYPE string.
<span data-anolis-ref class=informative>HTML</span>

<hr>

<dl class=domintro>
 <dt><var title>document</var> . <code title=dom-Document-compatMode>compatMode</code>
 <dd>
  <p>Returns the string "<code title>CSS1Compat</code>" if the
  <span>context object</span> is in
  <span title=concept-no-quirks-mode>no-quirks mode</span> or
  <span title=concept-limited-quirks-mode>limited-quirks mode</span>, and
  "<code title>BackCompat</code>", if the <code>Document</code> is in
  <span title=concept-quirks-mode>quirks mode</span>.
</dl>

<p>The <dfn title=dom-Document-implementation><code>implementation</code></dfn> attribute must return the <code>DOMImplementation</code> object that is associated with the <code>Document</code> node.

<p class=XXX><dfn title=dom-Document-documentURI>documentURI</dfn>
Should document.documentURI really exist? be readonly?

<p>The <dfn title=dom-Document-compatMode><code>compatMode</code></dfn> IDL
attribute must return the literal string "<code title>CSS1Compat</code>" unless
the <span>context object</span> is in <span
title=concept-quirks-mode>quirks mode</span>, in which case it must instead
return the literal string "<code title>BackCompat</code>".

<!-- <dfn title=dom-Document-xmlVersion>xmlVersion</dfn>
http://lists.w3.org/Archives/Public/www-dom/2003JulSep/0049.html -->

<hr>

<dl class=domintro>
 <dt><var title>collection</var> = <var title>document</var> . <code
 title=dom-Document-getElementsByClassName>getElementsByClassName(<var
 title>classes</var>)</code>
 <dt><var title>collection</var> = <var title>element</var> . <code
 title=dom-Element-getElementsByClassName>getElementsByClassName(<var
 title>classes</var>)</code>
 <dd>
  <p>Returns a <code>NodeList</code> of the elements in the object on which the
  method was invoked (a <code>Document</code> or an <code>Element</code>) that
  have all the classes given by <var title>classes</var>.
  <p>The <var title>classes</var> argument is interpreted as a space-separated
  list of classes.
</dl>

<p>The <dfn title=dom-Document-doctype><code>doctype</code></dfn> attribute must return the child of the <code>Document</code> node that is a <code>DocumentType</code> node, if there is one, or null otherwise.

<p>The
<dfn title=dom-Document-documentElement><code>documentElement</code></dfn>
attribute must return the <span>document element</span>.

<p>The <dfn
title=dom-Document-getElementsByTagName><code>getElementsByTagName(<var
title>localName</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var title>localName</var> is "<code>*</code>" (U+002A),
 return a <code>NodeList</code> rooted at the <span>context object</span>,
 whose filter matches only <code>Element</code> nodes.

 <li>
  <p>Otherwise, if the <span>context object</span> is an
  <span>HTML document</span>, return a <code>NodeList</code> rooted at the
  <span>context object</span>, whose filter matches only the following nodes:

  <ul>
   <li><code>Element</code> nodes in the <span>HTML namespace</span> whose <span title=concept-element-local-name>local name</span> is
   <var title>localName</var> <span>converted to lowercase</span>.

   <li><code>Element</code> nodes, <em>not</em> in the
   <span>HTML namespace</span>, whose
   <span title=concept-element-local-name>local name</span> is
   <var title>localName</var>.
  </ul>

 <li><p>Otherwise, return a <code>NodeList</code> rooted at the
 <span>context object</span>, whose filter matches only <span title=concept-element>elements</span> whose <span title=concept-element-local-name>local name</span> is
 <var title>localName</var>.
</ol>
<p>When invoked with the same argument the same <code>NodeList</code> object may be returned as returned by an earlier call.

<p class=note>Thus, in an <span>HTML document</span>,
<code title>document.getElementsByTagName("FOO")</code> will match
<code title>FOO</code> elements that are not in the
<span>HTML namespace</span>, and <code title>foo</code> elements that are in
the <span>HTML namespace</span>, but not <code title>FOO</code> elements
that are in the <span>HTML namespace</span>.


<p>The <dfn title=dom-Document-getElementsByTagNameNS><code>getElementsByTagNameNS(<var title>namespace</var>, <var title>localName</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>If both <var title>namespace</var> and <var title>localName</var> are
 "<code>*</code>" (U+002A) return a <code>NodeList</code> rooted at the
 <span>context object</span>, whose filter matches only <span title=concept-element>elements</span>.
 <li><p>Otherwise, if just <var title>namespace</var> is "<code>*</code>"
 (U+002A), return a <code>NodeList</code> rooted at the
 <span>context object</span>, whose filter matches only <span title=concept-element>elements</span> whose <span title=concept-element-local-name>local name</span> is
 <var title>localName</var>.
 <li><p>Otherwise, if just <var title>localName</var> is "<code>*</code>"
 (U+002A), return a <code>NodeList</code> rooted at the
 <span>context object</span>, whose filter matches only <span title=concept-element>elements</span> whose <span title=concept-element-namespace>namespace</span> is
 <var title>namespace</var>.
 <li><p>Otherwise, return a <code>NodeList</code> rooted at the
 <span>context object</span>, whose filter matches only <span title=concept-element>elements</span> whose <span title=concept-element-namespace>namespace</span> is
 <var title>namespace</var> and
 <span title=concept-element-local-name>local name</span> is
 <var title>localName</var>.
</ol>
<p>When invoked with the same argument the same <code>NodeList</code> object may be returned as returned by an earlier call.



<p>The <dfn
title=dom-Document-getElementsByClassName><code>getElementsByClassName(<var
title>classNames</var>)</code></dfn> method takes a string that contains a
<span>set of space-separated tokens</span> representing <span
title=concept-class>classes</span>. When called, the method must return a <span
title=concept-collection-live>live</span> <code>NodeList</code> object
containing all the elements in the <span>context object</span>, in <span>tree
order</span>, that have all the <span title=concept-class>classes</span>
specified in the <var title>classNames</var> argument, having obtained the
<span title=concept-class>classes</span> by <span title="split a string on
spaces">splitting the string on spaces</span>. (Duplicates are ignored.) If
there are no tokens specified in the argument, then the method must return an
empty <code>NodeList</code>. If the document is in <span
title=concept-quirks-mode>quirks mode</span>, then the comparisons for the <span
title=concept-class>classes</span> must be done in an <span>ASCII
case-insensitive</span> manner, otherwise, the comparisons must be done in a
<span>case-sensitive</span> manner.
<p>When invoked with the same argument the same <code>NodeList</code> object may be returned as returned by an earlier call.

<div class="example">
 <p>Given the following XHTML fragment:

 <pre>&lt;div id="example"&gt;
  &lt;p id="p1" class="aaa bbb"/&gt;
  &lt;p id="p2" class="aaa ccc"/&gt;
  &lt;p id="p3" class="bbb ccc"/&gt;
&lt;/div&gt;</pre>

 <p>A call to
 <code title=dom-Element-getElementsByClassName>document.getElementById('example').getElementsByClassName('aaa')</code>
 would return a <code>NodeList</code> with the two paragraphs
 <code title>p1</code> and <code title>p2</code> in it.

 <p>A call to
 <code title=dom-Element-getElementsByClassName>getElementsByClassName('ccc&nbsp;bbb')</code>
 would only return one node, however, namely <code title>p3</code>. A call to
 <code title=dom-Element-getElementsByClassName>document.getElementById('example').getElementsByClassName('bbb&nbsp;&nbsp;ccc&nbsp;')</code>
 would return the same thing.

 <p>A call to
 <code title=dom-Element-getElementsByClassName>getElementsByClassName('aaa,bbb')</code>
 would return no nodes; none of the elements above are in the
 <code title>aaa,bbb</code> class.
</div>

<!-- v2:
>         * xGetParentElementByClassName(rootElement, className, tagName) -
> Navigates upwards until we hit a parent element with the given class name and
> optional tag name.
-->

<p>The
<dfn title=dom-Document-getElementById><code>getElementById(<var title>elementId</var>)</code></dfn>
method must return the first <span title=concept-element>element</span>, in
<span>tree order</span>, within the <span>context object</span>'s
<span title=concept-tree>tree</span>, whose <span title=concept-ID>ID</span>
is <var title>elementId</var>, or null if there is none.

<hr>

<p>The <dfn title=dom-Document-createElement><code>createElement(<var title>localName</var>)</code></dfn> method must run the these steps:

<ol>
 <li><p>If <var title>localName</var> does not match the <code
 data-anolis-spec=xml>Name</code> production in XML, throw an
 <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li><p>If the <span>context object</span> is an <span>HTML document</span>,
 let <var title>localName</var> be <span>converted to lowercase</span>.
 <!-- XXX why restrict this to HTML documents? -->

 <li><p>Return a new <span title=concept-element>element</span> with no
 attributes,
 <span title=concept-element-namespace>namespace</span> set to the
 <span>HTML namespace</span>,
 <span title=concept-element-local-name>local name</span> set to
 <var title>localName</var>, and
 <code title=dom-Node-ownerDocument>ownerDocument</code> set to the
 <span>context object</span>.
</ol>

<p>The
<dfn title=dom-Document-createElementNS><code>createElementNS(<var title>namespace</var>, <var title>qualifiedName</var>)</code></dfn>
method must run these steps:
<ol>
 <li><p>If <var title>qualifiedName</var> does not match the
 <code data-anolis-spec=xml>Name</code> production in XML, throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.
 <li><p>If <var title>qualifiedName</var> does not match the
 <code data-anolis-spec=xmlns>QName</code> production in Namespaces in XML,
 throw a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code>
 exception and terminate these steps.
 <li><p>If <var title>qualifiedName</var> contains a "<code>:</code>" (U+003E),
 then split the string on it and let <var title>prefix</var> be the part before
 and <var title>localName</var> the part after. Otherwise, let <var title>prefix</var>
 be null and <var title>localName</var> be <var title>qualifiedName</var>.
 <li><p>If <var title>prefix</var> is not null and <var title>namespace</var> is an
 empty string, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.
 <li><p>If <var title>prefix</var> is "<code title>xml</code>" and
 <var title>namespace</var> is not the <span>XML namespace</span>, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.
 <li><p>If <var title>qualifiedName</var> or <var title>prefix</var> is
 "<code title>xmlns</code>" and <var title>namespace</var> is not the
 <span>XMLNS namespace</span>, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.
 <li><p>If <var title>namespace</var> is the <span>XMLNS namespace</span> and
 neither <var title>qualifiedName</var> nor <var title>prefix</var> is
 "<code title>xmlns</code>", throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.
 <li><p>Return a new <span title=concept-element>element</span> with no attributes,
 <span title=concept-element-namespace>namespace</span> set to <var title>namespace</var>,
 <span title=concept-element-namespace-prefix>namespace prefix</span> set to
 <var title>prefix</var>, <span title=concept-element-local-name>local name</span>
 set to <var title>localName</var>, and
 <code title=dom-Node-ownerDocument>ownerDocument</code> set to the
 <span>context object</span>.
</ol>

<p>The
<dfn title=dom-Document-createDocumentFragment><code>createDocumentFragment()</code></dfn>
method must return a new <code>DocumentFragment</code> node with its
<code title=dom-Node-ownerDocument>ownerDocument</code> set to the
<span>context object</span>.

<p>The <dfn title=dom-Document-createTextNode><code>createTextNode(<var title>data</var>)</code></dfn> method must return a new <code>Text</code> node with its <code title=dom-CharacterData-data>data</code> attribute set to <var title>data</var> and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context object</span>.
<p class=note>No check is performed that the text node contains characters that
match the <code data-anolis-spec=xml>Char</code> production in XML.

<p>The <dfn title=dom-Document-createComment><code>createComment(<var title>data</var>)</code></dfn> method must return a new <code>Comment</code> node with its <code title=dom-CharacterData-data>data</code> attribute set to <var title>data</var> and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context object</span>.
<p class=note>No check is performed that the comment contains characters that
match the <code data-anolis-spec=xml>Char</code> production in XML or that it
contains two adjacent hyphens or ends with a hyphen.

<p>The <dfn title=dom-Document-createProcessingInstruction><code
>createProcessingInstruction(<var title>target</var>, <var
title>data</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If the <span>context object</span> is an <span>HTML document</span>, throw
 a <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>target</var> does not match the <!--<code
 data-anolis-spec=xml>PITarget</code>--> <code data-anolis-spec=xml>Name</code>
 production in XML, throw an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps. <!-- DOM3 didn't check for "xml" -->

 <li><p>If <var title>data</var> contains the string "<code title>?></code>",
 throw an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps. <!-- Gecko does this. -->

 <!--<li><p>If <var title>target</var> contains a U+003A COLON (":") character, throw a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and terminate these steps.--> <!-- DOM3 didn't check this -->

 <li><p>Return a new <code>ProcessingInstruction</code>, with
 <span title=concept-PI-target>target</span> set to <var title>target</var>,
 <span title=concept-PI-data>data</span> set to <var title>data</var>, and
 <code title=dom-Node-ownerDocument>ownerDocument</code> set to the
 <span>context object</span>.
</ol>

<p class=note>No check is performed that the processing instruction target
contains "xml" or the colon, or that the data contains characters that match the
<code data-anolis-spec=xml>Char</code> production in XML.

<!--
[createAttribute]
<p>The <dfn title=dom-Document-createAttribute><code>createAttribute(<var title>name</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>If <var title>name</var> does not match the <code data-anolis-spec=xml>Name</code> production in XML, throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.
 <li><p>Return a new <code>Attr</code> node with its <code title=dom-Node-namespaceURI>namespaceURI</code> set to null, <code title=dom-Node-prefix>prefix</code> set to null, <code title=dom-Node-localName>localName</code> set to <var title>name</var>, and <code title=dom-Node-ownerDocument>ownerDocument</code> set to the <span>context object</span>.
</ol>-->
<!-- this is different from DOM3 -->
<!--<p class=note>No check is performed that the local name will match the <code
data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML.-->

<hr>

<p>The
<dfn title=dom-Document-importNode><code>importNode(<var title>node</var>, <var title>deep</var>)</code></dfn>
method must return a <span>clone</span> of <var title>node</var>, with
<var title>new ownerDocument</var> being the <span>context object</span>, and the
<i>clone children flag</i> set if <var title>deep</var> is true.

<p>The
<dfn title=dom-Document-adoptNode><code>adoptNode(<var title>node</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If <var title>node</var> is of type <code>Document</code> or
 <code>DocumentType</code>, throw a
 <code title=dom-DOMException-NOT_SUPPORTED_ERR>NOT_SUPPORTED_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>node</var> is of type <code>Element</code>, it is
 <span>affected by a base URL change</span>.

 <li><p>If <var title>node</var>'s
 <span title=concept-tree-parent>parent</span> is not null, remove
 <var title>node</var> from its
 <span title=concept-tree-parent>parent</span>.

 <li><p>Set <code title=dom-Node-ownerDocument>ownerDocument</code> for
 <var title>node</var> and all its <span title=concept-tree-descendant>descendants</span><!--AttrExodus as well as any associated
 <code>Attr</code> nodes--> to the <span>context object</span>.

 <li><p>Return <var title>node</var>.
</ol>


<h4>Interface <code>DOMImplementation</code></h4>
<p>User agents must create a new <code>DOMImplementation</code> object
whenever a new <code>Document</code> object is created and associate it with
that <code>Document</code> object.

<pre class=idl>interface <dfn>DOMImplementation</dfn> {
  boolean <span title=dom-DOMImplementation-hasFeature>hasFeature</span>(DOMString feature, [TreatNullAs=EmptyString] DOMString version);

  <span>DocumentType</span> <span title=dom-DOMImplementation-createDocumentType>createDocumentType</span>([TreatNullAs=EmptyString] DOMString qualifiedName, DOMString publicId, DOMString systemId);
  <span>Document</span> <span title=dom-DOMImplementation-createDocument>createDocument</span>([TreatNullAs=EmptyString] DOMString namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, <span>DocumentType</span> doctype);<!--
  DOMObject getFeature(DOMString feature, DOMString version);-->
  <span>Document</span> <span title=dom-DOMImplementation-createHTMLDocument>createHTMLDocument</span>(DOMString title);
};</pre>

<dl class=domintro>
 <dt><var title>hasSupport</var> = <var title>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-hasFeature>hasFeature</code>(
 <var title>feature</var>, <var title>version</var> )

 <dd>
  <p>Returns whether the user agent supports the version <var
  title>version</var> of <var title>feature</var>. The empty string means any
  version.
</dl>

<div class=impl>

<p>The <dfn title=dom-DOMImplementation-hasFeature><code>hasFeature(<var
title>feature</var>, <var title>version</var>)</code></dfn> method must return
true if the user agent <span title=concept-support-DOMfeatureversion>supports</span>
the (<var title>feature</var>, <var title>version</var>) tuple and false
otherwise.

</div>

<hr>

<dl class=domintro>
 <dt><var title>doctype</var> = <var title>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-createDocumentType>createDocumentType</code>(
 <var title>qualifiedName</var>, <var title>publicId</var>, <var
 title>systemId</var> )

 <dd>
  <p>Returns a new <code>DocumentType</code>, with the given <var
  title>qualifiedName</var>, <var title>publicId</var>, and <var
  title>systemId</var>. If <var
  title>qualifiedName</var> does not match the <code
  data-anolis-spec=xml>Name</code> production in XML, an <code
  title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
  exception is thrown, and if it does not match the <code
  data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, a <code
  title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception is thrown.


 <dt><var title>doc</var> = <var title>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-createDocument>createDocument</code>( <var title>namespace</var>, <var title>qualifiedName</var>, <var title>doctype</var> )

 <dd>
  <p>Returns a new <code>Document</code>, with a new root
  <code>Element</code> whose
  <span title=concept-element-local-name>local name</span> is
  <var title>qualifiedName</var> and whose
  <span title=concept-element-namespace>namespace</span> is
  <var title>namespace</var> (unless <var title>qualifiedName</var> is the
  empty string), and with <var title>doctype</var>, if it is given, as its
  <code>DocumentType</code>.

  <p>This method throws the same exceptions as the <code
  title=dom-Document-createElementNS>createElementNS</code> method, when
  invoked with the same arguments. If <var title>doctype</var> comes from
  another <code>Document</code>, a
  <code title=dom-DOMException-WRONG_DOCUMENT_ERR>WRONG_DOCUMENT_ERR</code> exception is thrown.


 <dt><var title>doc</var> = <var title>document</var> . <code
 title=dom-Document-implementation>implementation</code> . <code
 title=dom-DOMImplementation-createHTMLDocument>createHTMLDocument</code>(
 <var title>title</var> )

 <dd>
  <p>Returns a new <code>Document</code>, with a basic DOM already
  constructed with an appropriate <code title>title</code> element.
</dl>

<div class=impl>

<p>The <dfn title=dom-DOMImplementation-createDocumentType><code>createDocumentType(<var title>qualifiedName</var>, <var title>publicId</var>, <var title>systemId</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>If <var title>qualifiedName</var> does not match the <code
 data-anolis-spec=xml>Name</code> production in XML, throw an <code
 title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.
 <li><p>If <var title>qualifiedName</var> does not match the <code
 data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception and
 terminate these steps.
 <!--<li><p>If <var title>publicId</var> contains a character that does not match the <code data-anolis-spec=xml>PubidChar</code> production in XML, throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps. --> <!-- DOM3 didn't check this -->
 <!--<li><p>If <var title>systemId</var> contains both a U+0022 QUOTATION MARK ('"') and a U+0027 APOSTROPHE ("'") character, throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.--> <!-- DOM3 didn't check this -->
 <li><p>Return a new <code>DocumentType</code>, with <var title>qualifiedName</var> as its <span
 title=concept-doctype-name>name</span>, <var title>publicId</var> as its <span
 title=concept-doctype-publicid>public ID</span>, and <var title>systemId</var>
 as its <span title=concept-doctype-systemid>system ID</span>, and with its
 <code title=dom-Node-ownerDocument>ownerDocument</code> set to null.
</ol>
<p class=note>No check is performed that the <var title>publicId</var> matches the <code title>PublicChar</code> production in XML or that the <var title>systemId</var> does not contain both a quotation mark (") and an apostrophe (').

<p>The <dfn title=dom-DOMImplementation-createDocument><code>createDocument(<var title>namespace</var>, <var title>qualifiedName</var>, <var title>doctype</var>)</code></dfn> method must run the following steps:

<ol>
 <li><p>Let <var title>document</var> be a new <code>Document</code> node.

 <li><p>Let <var title>element</var> be null.

 <li><p>If <var title>qualifiedName</var> is not the empty string, set
 <var title>element</var> to the result of invoking the
 <code title=dom-Document-createElementNS>createElementNS</code> method with the
 arguments <var title>namespace</var> and <var title>qualifiedName</var> on
 <var title>document</var>. If that threw an exception, terminate these steps.

 <li>
  <p>If <var title>doctype</var> is not null, run the following substeps:

  <ol>
   <li><p>If the <var title>doctype</var>'s
   <code title=dom-Node-ownerDocument>ownerDocument</code> is not null, throw a
   <code title=dom-DOMException-WRONG_DOCUMENT_ERR>WRONG_DOCUMENT_ERR</code>
   exception and terminate the overall set of steps.

   <li><p>Set the <var title>doctype</var>'s
   <code title=dom-Node-ownerDocument>ownerDocument</code> to
   <var title>document</var>.

   <li><p>Append <var title>doctype</var> to <var title>document</var>.
  </ol>

 <li><p>If <var title>element</var> is not null, append <var title>element</var>
 to <var title>document</var>.

 <li><p>Return <var title>document</var>.
</ol>

<p>The <dfn
title=dom-DOMImplementation-createHTMLDocument><code>createHTMLDocument(<var
title>title</var>)</code></dfn> method, when invoked, must run the following
steps:

<ol>
 <li><p>Let <var title>doc</var> be a newly created <code>Document</code>
 object.

 <li><p>Mark <var title>doc</var> as being an <span>HTML document</span>.

 <li><p>Create a new <code>DocumentType</code>, with "<code title>html</code>" as its <span
 title=concept-doctype-name>name</span> and with its <code
 title=dom-Node-ownerDocument>ownerDocument</code> set to <var title>doc</var>. Append the newly created node to <var title>doc</var>.

 <li><p>Create an <code title>html</code> element in the <span>HTML
 namespace</span>, and append it to <var title>doc</var>.

 <li><p>Create a <code title>head</code> element in the <span>HTML
 namespace</span>, and append it to the <code title>html</code> element created in the previous step.

 <li><p>Create a <code title>title</code> element in the <span>HTML
 namespace</span>, and append it to the <code title>head</code> element created in the previous step.

 <li><p>Create a <code>Text</code> node, and set its <code
 title=dom-CharacterData-data>data</code> attribute to the string given by the
 method's argument (which could be the empty string). Append it to the
 <code title>title</code> element created in the previous step.

 <li><p>Create a <code title>body</code> element in the <span>HTML
 namespace</span>, and append it to the <code title>html</code> element created
 in the earlier step.

 <li><p>Return <var title>doc</var>.
</ol>

</div>

<!-- AttrExodus
<h3>Interface <code>Attr</code></h3>

<p>The tentative plan is to let <code>Attr</code> no longer have
child nodes and turn it into a very lightweight object that no longer
inherits from <code>Node</code> &mdash;
<a href=http://lists.w3.org/Archives/Public/public-webapps/2010JulSep/0797.html>http://lists.w3.org/Archives/Public/public-webapps/2010JulSep/0797.html</a>

<pre class=idl>interface <dfn>Attr</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-Attr-name>name</span>;
  readonly attribute boolean <span title=dom-Attr-specified>specified</span>;
           attribute DOMString <span title=dom-Attr-value>value</span>;
  readonly attribute <span>Element</span> <span title=dom-Attr-ownerElement>ownerElement</span>;<!- -
  readonly attribute TypeInfo schemaTypeInfo;
  readonly attribute boolean isId;- ->
};</pre>

<p><code>Attr</code> nodes represent <dfn
title=concept-attribute>attributes</dfn>. They have a <dfn
title=concept-attribute-name>name</dfn> and an <dfn
title=concept-attribute-element>element</dfn> associated with them when they are
created<!- -, or when they are passed as the argument to the <code
title=dom-Element-setAttributeNode>setAttributeNode</code> method.
[createAttribute]- ->. <code>Attr</code> nodes are not considered part of the
document tree, so their <code title=dom-Node-parentNode>parentNode</code>, <code
title=dom-Node-previousSibling>previousSibling</code> and <code
title=dom-Node-nextSibling>nextSibling</code> attributes return null. Also, its
child nodes can not be manipulated directly through the <code
title=dom-Node-insertBefore>insertBefore</code>, <code
title=dom-Node-replaceChild>replaceChild</code> and <code
title=dom-Node-appendChild>appendChild</code> methods.

<p>The <dfn title=dom-Attr-name><code>name</code></dfn> attribute must return
the <span title=concept-attribute-name>name</span> associated with the
<span>context object</span>.

<p>The <dfn title=dom-Attr-specified><code>specified</code></dfn> attribute must
return true.

<p>The <dfn title=dom-Attr-value><code>value</code></dfn> attribute must return the value of the <span>context object</span>'s
<code title=dom-Node-textContent>textContent</code> attribute and on
setting, must set the <span>context object</span>'s
<code title=dom-Node-textContent>textContent</code> attribute to the given
value.

<p>The <dfn title=dom-Attr-ownerElement><code>ownerElement</code></dfn>
attribute must return the <span title=concept-attribute-element>element</span>
associated with the <span>context object</span><!- -, if there is one, or null
otherwise [createAttribute]- ->.
-->


<h3>Interface <code>Element</code></h3>
<pre class=idl>interface <dfn>Element</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-Element-namespaceURI>namespaceURI</span>;
  readonly attribute DOMString <span title=dom-Element-prefix>prefix</span>;
  readonly attribute DOMString <span title=dom-Element-localName>localName</span>;
  readonly attribute DOMString <span title=dom-Element-tagName>tagName</span>;

  readonly attribute <span>Attr</span>[] <span title=dom-Element-attributes>attributes</span>;
  DOMString? <span title=dom-Element-getAttribute>getAttribute</span>(DOMString <var title>qualifiedName</var>);
  DOMString? <span title=dom-Element-getAttributeNS>getAttributeNS</span>(DOMString <var title>namespace</var>, DOMString <var title>localName</var>);
  void <span title=dom-Element-setAttribute>setAttribute</span>(DOMString <var title>qualifiedName</var>, DOMString <var title>value</var>);
  void <span title=dom-Element-setAttributeNS>setAttributeNS</span>(DOMString <var title>namespace</var>, DOMString <var title>qualifiedName</var>, DOMString <var title>value</var>);
  void <span title=dom-Element-removeAttribute>removeAttribute</span>(DOMString <var title>qualifiedName</var>);
  void <span title=dom-Element-removeAttributeNS>removeAttributeNS</span>(DOMString <var title>namespace</var>, DOMString <var title>localName</var>);
  boolean <span title=dom-Element-hasAttribute>hasAttribute</span>(DOMString <var title>qualifiedName</var>);
  boolean <span title=dom-Element-hasAttributeNS>hasAttributeNS</span>(DOMString <var title>namespace</var>, DOMString <var title>localName</var>);
<!--
  <span>Attr</span> <span title=dom-Element-getAttributeNode>getAttributeNode</span>(DOMString name);
  <span>Attr</span> <span title=dom-Element-getAttributeNodeNS>getAttributeNodeNS</span>(DOMString namespace, DOMString localName);
  <span>Attr</span> <span title=dom-Element-setAttributeNode>setAttributeNode</span>(Attr newAttr);
  <span>Attr</span> <span title=dom-Element-removeAttributeNode>removeAttributeNode</span>(Attr oldAttr);
-->
  <span>NodeList</span> <span title=dom-Element-getElementsByTagName>getElementsByTagName</span>(DOMString <var title>qualifiedName</var>);
  <span>NodeList</span> <span title=dom-Element-getElementsByTagNameNS>getElementsByTagNameNS</span>(DOMString <var title>namespace</var>, DOMString <var title>localName</var>);
  <span>NodeList</span> <span title=dom-Element-getElementsByClassName>getElementsByClassName</span>(DOMString <var title>classNames</var>);

  readonly attribute <span>HTMLCollection</span> <span title=dom-Element-children>children</span>;
  readonly attribute <span>Element</span> <span title=dom-Element-firstElementChild>firstElementChild</span>;
  readonly attribute <span>Element</span> <span title=dom-Element-lastElementChild>lastElementChild</span>;
  readonly attribute <span>Element</span> <span title=dom-Element-previousElementSibling>previousElementSibling</span>;
  readonly attribute <span>Element</span> <span title=dom-Element-nextElementSibling>nextElementSibling</span>;
  readonly attribute unsigned long <span title=dom-Element-childElementCount>childElementCount</span>;<!--

  readonly attribute TypeInfo schemaTypeInfo;
  void setIdAttribute(DOMString name, boolean isId);
  void setIdAttributeNS(DOMString namespace, DOMString localName, boolean isId);
  void setIdAttributeNode(Attr idAttr, boolean isId);-->
};</pre>

<p><code>Element</code> objects are simply known as
<dfn title=concept-element>elements</dfn>.</p>

<p><span title=concept-element>Elements</span> have an associated <dfn title=concept-element-namespace>namespace</dfn>, <dfn title=concept-element-namespace-prefix>namespace prefix</dfn>, <dfn title=concept-element-local-name>local name</dfn>.

<p>When an <span title=concept-element>element</span> is created, its <span title=concept-element-local-name>local name</span> is always given. Unless explicitly given when an <span title=concept-element>element</span> is created, its <span title=concept-element-namespace>namespace</span> and <span title=concept-element-namespace-prefix>namespace prefix</span> are null.

<p><span title=concept-element>Elements</span> also have an associated
collection of <code>Attr</code> objects, often called attributes.

<p><span title=concept-element>Elements</span> can have a
<dfn title=concept-id>unique identifier (ID)</dfn> and
<dfn title=concept-class>classes</dfn> associated with them.

<p class=XXX>I think rather than leaving this up to markup specifications we
should just state that id="" sets the ID and class="" sets the classes. We
can then also define Element.id, Element.className, and Element.classList
here. It would simplify a lot of stuff.

<hr>

<p>A <span title=concept-node>node</span>'s
<span title=concept-tree-parent>parent</span> of type
<code>Element</code> is known as a <dfn>parent element</dfn>. If the
<span title=concept-node>node</span> has a
<span title=concept-tree-parent>parent</span> of a different type, its
<span>parent element</span> is null.</p>

<p>An <span title=concept-element>element</span> is known as the
<dfn>document element</dfn> when its
<span title=concept-tree-parent>parent</span> is of type
<code>Document</code>.</p>

<p>When an <span title=concept-element>element</span> or one of its
<span title=concept-tree-ancestor>ancestors</span> is the
<span>document element</span>, it is <dfn>in a <code>Document</code></dfn>.

<hr>

<p>Specifications may define <dfn>base URL change steps</dfn>.

<p>When an <span title=concept-element>element</span> is
<dfn>affected by a base URL change</dfn>, the user agent must run the
<span>base URL change steps</span>, as defined in
<span>other applicable specifications</span>.

<hr>

<p>The <dfn title=dom-Element-namespaceURI><code>namespaceURI</code></dfn>
attribute must return the <span>context object</span>'s
<span title=concept-element-namespace>namespace</span>.

<p>The <dfn title=dom-Element-prefix><code>prefix</code></dfn> attribute must return the <span>context object</span>'s
<span title=concept-element-namespace-prefix>namespace prefix</span>.

<p>The <dfn title=dom-Element-localName><code>localName</code></dfn>
attribute must return the <span>context object</span>'s
<span title=concept-element-local-name>local name</span>.

<p>The <dfn title=dom-Element-tagName><code>tagName</code></dfn> attribute
must run these steps:
<ol>
 <li><p>If <span>context object</span>'s
 <span title=concept-element-namespace-prefix>namespace prefix</span> is not
 null, let <var title>qualified name</var> be its
 <span title=concept-element-namespace-prefix>namespace prefix</span>, followed
 by a "<code>:</code>" (U+003A), followed by its
 <span title=concept-element-local-name>local name</span>. Otherwise, let
 <var title>qualified name</var> be its
 <span title=concept-element-local-name>local name</span>.

 <li><p>If the <span>context object</span> is in the <span>HTML namespace</span> and
 its <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var title>qualified name</var> be
 <span>converted to uppercase</span>.

 <li><p>Return <var title>qualified name</var>.
</ol>

<hr>

<!-- all members in this subsection are affected by AttrExodus -->

<p>The <dfn title=dom-Element-attributes><code>attributes</code></dfn>
attribute must return a read only array<!--XXX WebIDL--> of the
<span>context object</span>'s associated <code>Attr</code> objects.

<p>The <dfn title=dom-Element-getAttribute><code>getAttribute(<var title>name</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>If the <span>context object</span> is in the
 <span>HTML namespace</span> and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var title>name</var> be <span>converted to lowercase</span>.

 <li><p>Return the <span title=concept-attr-value>value</span> of the first
 <code>Attr</code> in the <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code> whose
 <span title=concept-attr-qualified-name>qualified name</span> is
 <var title>name</var>, if the <code>Attr</code> is present, or null otherwise.
</ol>

<p>The
<dfn title=dom-Element-getAttributeNS><code>getAttributeNS(<var title>namespace</var>, <var title>localName</var>)</code></dfn>
method must return the <span title=concept-attr-value>value</span> of the
<code>Attr</code> in the <span>context object</span>'s
<code title=dom-Element-attributes>attributes</code> whose
<span title=concept-attr-namespace>namespace</span> is
<var title>namespace</var> and
<span title=concept-attr-local-name>local name</span> is
<var title>localName</var>, if the <code>Attr</code> is present, or null
otherwise.

<p>The
<dfn title=dom-Element-setAttribute><code>setAttribute(<var title>qualifiedName</var>, <var title>value</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If <var title>qualifiedName</var> does not match the
 <code data-anolis-spec=xml>Name</code> production in XML, throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li><p>If the <span>context object</span> is in the <span>HTML namespace</span>
 and its <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var title>qualifiedName</var> be
 <span>converted to lowercase</span>.

 <!-- https://bugzilla.mozilla.org/show_bug.cgi?id=315805 -->
 <li><p>If "<code title>xmlns</code>" is a <span>prefix match</span> for
 <var title>qualifiedName</var>, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> and
 terminate these steps.

 <li><p>If the <span>context object</span> does not have an <code>Attr</code>
 object whose <span title=concept-attr-local-name>local name</span> is
 <var title>qualifiedName</var>, create an <code>Attr</code> object, whose
 <span title=concept-attr-local-name>local name</span> is
 <var title>qualifiedName</var> and <span title=concept-attr-value>value</span>
 is <var title>value</var>. Append this object to the
 <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code>.

 <li><p>Otherwise, set the <span title=concept-attr-value>value</span> of
 the first <code>Attr</code> object in the <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code> whose
 <span title=concept-attr-qualified-name>qualified name</span> is
 <var title>qualifiedName</var>, to <var title>value</var>.
</ol>

<p>The
<dfn title=dom-Element-setAttributeNS><code>setAttributeNS(<var title>namespace</var>, <var title>qualifiedName</var>, <var title>value</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If <var title>qualifiedName</var> does not match the
 <code data-anolis-spec=xml>Name</code> production in XML, throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>qualifiedName</var> does not match the
 <code data-anolis-spec=xmlns>QName</code> production in Namespaces in XML,
 throw a <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code>
 exception and terminate these steps.

 <li><p>If <var title>qualifiedName</var> contains a "<code>:</code>" (U+003E),
 then split the string on it and let <var title>prefix</var> be the part before
 and <var title>localName</var> the part after. Otherwise, let
 <var title>prefix</var> be null and <var title>localName</var> be
 <var title>qualifiedName</var>.

 <li><p>If <var title>namespace</var> is the empty string, let
 <var title>namespace</var> be null.

 <li><p>If <var title>prefix</var> is not null and <var title>namespace</var> is
 null, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.

 <li><p>If <var title>prefix</var> is "<code title>xml</code>" and
 <var title>namespace</var> is not the <span>XML namespace</span>, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.

 <li><p>If <var title>qualifiedName</var> or <var title>prefix</var> is
 "<code title>xmlns</code>" and <var title>namespace</var> is not the
 <span>XMLNS namespace</span>, throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.

 <li><p>If <var title>namespace</var> is the <span>XMLNS namespace</span> and
 neither <var title>qualifiedName</var> nor <var title>prefix</var> is
 "<code title>xmlns</code>", throw a
 <code title=dom-DOMException-NAMESPACE_ERR>NAMESPACE_ERR</code> exception
 and terminate these steps.

 <li><p>If the <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code> does not contain an
 <code>Attr</code> object whose
 <span title=concept-attr-namespace>namespace</span> is
 <var title>namespace</var> and
 <span title=concept-attr-local-name>local name</span> is
 <var title>localName</var>, create an <code>Attr</code> object, whose
 <span title=concept-attr-namespace>namespace</span> is
 <var title>namespace</var>,
 <span title=concept-attr-namespace-prefix>namespace prefix</span> is
 <var title>prefix</var>, <span title=concept-attr-local-name>local name</span>
 is <var title>localName</var>, and <span title=concept-attr-value>value</span>
 is <var title>value</var>. Append this object to the
 <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code>.

 <li><p>Otherwise, set the <span title=concept-attr-value>value</span> of
 the <code>Attr</code> object in the <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code> whose
 <span title=concept-attr-namespace>namespace</span> is
 <var title>namespace</var>, and
 <span title=concept-attr-local-name>local name</span> is
 <var title>localName</var>, to <var title>value</var>, and set its
 <span title=concept-attr-namespace-prefix>namespace prefix</span> to
 <var title>prefix</var>.
</ol>

<p>The
<dfn title=dom-Element-removeAttribute><code>removeAttribute(<var title>qualifiedName</var>)</code></dfn>
method must run the following steps:
<ol>
 <li><p>If the <span>context object</span> is in the <span>HTML namespace</span>
 and its <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var title>qualifiedName</var> be
 <span>converted to lowercase</span>.

 <li><p>Remove the first <code>Attr</code> object in the
 <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code> whose
 <span title=concept-attr-qualified-name>qualified name</span> is
 <var title>qualifiedName</var>.
</ol>

<p>The
<dfn title=dom-Element-removeAttributeNS><code>removeAttributeNS(<var title>namespace</var>, <var title>localName</var>)</code></dfn>
method must remove the <code>Attr</code> object in the
<span>context object</span>'s
<code title=dom-Element-attributes>attributes</code> whose
<span title=concept-attr-namespace>namespace</span> is
<var title>namespace</var> and
<span title=concept-attr-local-name>local name</span> is
<var title>localName</var>

<p>The
<dfn title=dom-Element-hasAttribute><code>hasAttribute(<var title>qualifiedName</var>)</code></dfn>
method must run these steps:
<ol>
 <li><p>If the <span>context object</span> is in the
 <span>HTML namespace</span> and its
 <code title=dom-Node-ownerDocument>ownerDocument</code> is an
 <span>HTML document</span>, let <var title>qualifiedName</var> be
 <span>converted to lowercase</span>.

 <li><p>Return true if <span>context object</span>'s
 <code title=dom-Element-attributes>attributes</code> contains an
 <code>Attr</code> whose
 <span title=concept-attr-qualified-name>qualified name</span> is
 <var title>qualifiedName</var>, or false otherwise.
</ol>

<p>The
<dfn title=dom-Element-hasAttributeNS><code>hasAttributeNS(<var title>namespace</var>, <var title>localName</var>)</code></dfn>
method must return true if <span>context object</span>'s
<code title=dom-Element-attributes>attributes</code> contains an
<code>Attr</code> whose <span title=concept-attr-namespace>namespace</span>
is <var title>namespace</var> and
<span title=concept-attr-local-name>local name</span> is
<var title>localName</var>, or false otherwise.

<!--<dfn title=dom-Element-getAttributeNode>getAttributeNode</dfn>: when the
Element.getAttributeNode() method is invoked on an HTML element, the name
argument must be converted to ASCII lowercase before the element's attributes
are examined. (In HTML documents.) -->

<!-- <dfn title=dom-Element-setAttributeNode>setAttributeNode</dfn>: when an
Attr node is set on an HTML element using Element.setAttributeNode(), it must
have its name converted to ASCII lowercase before the element is affected.
(In HTML documents.) -->

<hr>

<p>When the
<dfn
title=dom-Element-getElementsByTagName><code>getElementsByTagName(<var
title>qualifiedName</var>)</code></dfn>
method is invoked it must return a
<span title=concept-collection-live>live</span> <code>NodeList</code> with
the <span title=concept-element>elements</span> that the
<code title=dom-Document-getElementsByTagName>getElementsByTagName</code>
method would return when called on the <span>context object</span>'s
<code title=dom-Node-ownerDocument>ownerDocument</code> and passed the same
argument, excluding any <span title=concept-element>elements</span> that are
not <span title=concept-tree-descendant>descendants</span> of the
<span>context object</span> on which the method was invoked.
<p>When invoked with the same argument the same <code>NodeList</code> object
may be returned as returned by an earlier call.


<p>When the
<dfn title=dom-Element-getElementsByTagNameNS><code>getElementsByTagNameNS(<var title>namespace</var>, <var title>localName</var>)</code></dfn>
method is invoked it must return a
<span title=concept-collection-live>live</span> <code>NodeList</code> with
the <span title=concept-element>elements</span> that the
<code title=dom-Document-getElementsByTagNameNS>getElementsByTagNameNS</code>
method would return when called on the <span>context object</span>'s
<code title=dom-Node-ownerDocument>ownerDocument</code> and
passed the same arguments, excluding any
<span title=concept-element>elements</span> that are
not <span title=concept-tree-descendant>descendants</span> of the
<span>context object</span> on which the method was invoked.
<p>When invoked with the same argument the same <code>NodeList</code> object
may be returned as returned by an earlier call.


<p>When the
<dfn
title=dom-Element-getElementsByClassName><code>getElementsByClassName(<var
title>classNames</var>)</code></dfn>
method is invoked it must return a <span title=concept-collection-live>live</span>
<code>NodeList</code> with the <span title=concept-element>elements</span>
that the <code
title="dom-Document-getElementsByClassName">getElementsByClassName</code>
method would return when called on the <span>context object</span>'s
<code title=dom-Node-ownerDocument>ownerDocument</code> and
passed the same argument, excluding any
<span title=concept-element>elements</span> that are not
<span title=concept-tree-descendant>descendants</span> of the
<span>context object</span> on which the method was invoked.
<p>When invoked with the same argument the same <code>NodeList</code> object
may be returned as returned by an earlier call.

<hr>

<p>The <dfn title=dom-Element-children><code>children</code></dfn> attribute
must return an <code>HTMLCollection</code>
<span title=concept-collection>collection</span>, rooted at the
<span>context object</span>, whose filter matches only
<span title=concept-element>elements</span> whose
<span title=concept-tree-parent>parent</span> is the
<span>context object</span>.

<p>The
<dfn title=dom-Element-firstElementChild><code>firstElementChild</code></dfn>
attribute must return the first <span title=concept-tree-child>child</span>
of the <span>context object</span> that is of type <code>Element</code> or
null if there is no such <span title=concept-node>node</span>.

<p>The
<dfn title=dom-Element-lastElementChild><code>lastElementChild</code></dfn>
attribute must return the last <span title=concept-tree-child>child</span>
of the <span>context object</span> that is of type <code>Element</code> or
null if there is no such <span title=concept-node>node</span>.

<p>The
<dfn title=dom-Element-previousElementSibling><code>previousElementSibling</code></dfn>
attribute must return the first
<span title=concept-tree-preceding-sibling>preceding sibling</span> of the
<span>context object</span> that is of type <code>Element</code> or null if
there is no such <span title=concept-node>node</span>.

<p>The
<dfn title=dom-Element-nextElementSibling><code>nextElementSibling</code></dfn>
attribute must return the first
<span title=concept-tree-following-sibling>following sibling</span> of the
<span>context object</span> that is of type <code>Element</code> or null if
there is no such <span title=concept-node>node</span>.

<p>The
<dfn title=dom-Element-childElementCount><code>childElementCount</code></dfn>
attribute must return the number of
<span title=concept-tree-child>children</span> of the <span>context node</span>
that are <code>Element</code>s.


<h4>Interface <code>Attr</code></h4>
<pre class=idl>interface <dfn>Attr</dfn> {
  readonly attribute DOMString? <span title=dom-Attr-namespaceURI>namespaceURI</span>;
  readonly attribute DOMString? <span title=dom-Attr-prefix>prefix</span>;
  readonly attribute DOMString <span title=dom-Attr-localName>localName</span>;
  readonly attribute DOMString <span title=dom-Attr-name>name</span>;
           attribute DOMString <span title=dom-Attr-value>value</span>;
};</pre>

<p>Just like <span title=concept-element>elements</span>, <code>Attr</code> objects have an associated <dfn title=concept-attr-namespace>namespace</dfn>, <dfn title=concept-attr-namespace-prefix>namespace prefix</dfn>, <dfn title=concept-attr-local-name>local name</dfn>, and <dfn title=concept-attr-qualified-name>qualified name</dfn>.

<p>When an <code>Attr</code> object is created its <span title=concept-attr-local-name>local name</span> is always given. Unless explicitly given when an <code>Attr</code> object is created, its <span title=concept-attr-namespace>namespace</span> and <span title=concept-attr-namespace-prefix>namespace prefix</span> are null and its <span title=concept-attr-qualified-name>qualified name</span> is its <span title=concept-attr-namespace-prefix>namespace prefix</span>, followed by a "<code>:</code>" (U+003A), followed by its <span title=concept-attr-local-name>local name</span>, if its <span title=concept-attr-namespace-prefix>namespace prefix</span> is not null, or otherwise <span title=concept-attr-qualified-name>qualified name</span> is just its <span title=concept-attr-local-name>local name</span>.

<p><code>Attr</code> objects also have an associated
<dfn title=concept-attr-value>value</dfn>, which is always given when an
<code>Attr</code> object is created.

<hr>

<p>The <dfn title=dom-Attr-namespaceURI><code>namespaceURI</code></dfn>
attribute must return the
<span title=concept-attr-namespace>namespace</span>.

<p>The <dfn title=dom-Attr-prefix><code>prefix</code></dfn> attribute must
return the
<span title=concept-attr-namespace-prefix>namespace prefix</span>.

<p>The <dfn title=dom-Attr-localName><code>localName</code></dfn> attribute
must return the <span title=concept-attr-local-name>local name</span>.

<p>The <dfn title=dom-Attr-name><code>name</code></dfn> attribute must
return the <span title=concept-attr-qualified-name>qualified name</span>.

<p>The <dfn title=dom-Attr-value><code>value</code></dfn> attribute must
return the <span title=concept-attr-value>value</span>.

<p>Setting the <code title=dom-Attr-value>value</code> attribute must set
<span title=concept-attr-value>value</span> to the given value.

<h3>Interface <code>DocumentType</code></h3>
<pre class=idl>interface <dfn>DocumentType</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-DocumentType-name>name</span>;<!--
  readonly attribute NamedNodeMap entities;
  readonly attribute NamedNodeMap notations;-->
  readonly attribute DOMString <span title=dom-DocumentType-publicId>publicId</span>;
  readonly attribute DOMString <span title=dom-DocumentType-systemId>systemId</span>;<!--
  readonly attribute DOMString internalSubset;-->
};</pre>

<p><code>DocumentType</code> nodes have an associated <dfn title=concept-doctype-name>name</dfn>, <dfn title=concept-doctype-publicid>public ID</dfn>, and <dfn title=concept-doctype-systemid>system ID</dfn>.

<p>When a <code>DocumentType</code> node is created, its <span title=concept-doctype-name>name</span> is always given. Unless explicitly given when a <code>DocumentType</code> node is created, its <span title=concept-doctype-publicid>public ID</span> and <span title=concept-doctype-systemid>system ID</span> are the empty string.

<p>The <dfn title=dom-DocumentType-name><code>name</code></dfn> attribute must return the <span>context object</span>'s <span
title=concept-doctype-name>name</span>.

<p>The <dfn title=dom-DocumentType-publicId><code>publicId</code></dfn>
attribute must return the <span>context object</span>'s <span title=concept-doctype-publicid>public ID</span>.

<p>The <dfn title=dom-DocumentType-systemId><code>systemId</code></dfn>
attribute must return the <span>context object</span>'s <span title=concept-doctype-systemid>system ID</span>.


<h3>Interface <code>ProcessingInstruction</code></h3>
<pre class=idl>interface <dfn>ProcessingInstruction</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-ProcessingInstruction-target>target</span>;
           attribute DOMString <span title=dom-ProcessingInstruction-data>data</span>;
};</pre>

<p><code>ProcessingInstruction</code> nodes have an associated <dfn
title=concept-PI-target>target</dfn> and <dfn title=concept-PI-data>data</dfn>. When a <code>ProcessingInstruction</code> node is created both are given.

<p>The <dfn title=dom-ProcessingInstruction-target><code>target</code></dfn>
attribute must return the <span>context object</span>'s <span title=concept-PI-target>target</span>.

<p>The <dfn title=dom-ProcessingInstruction-data><code>data</code></dfn>
attribute must return the <span>context object</span>'s <span title=concept-PI-data>data</span>, and on setting, set the
<span>context object</span>'s <span title=concept-PI-data>data</span> to the new value.


<h3>Interface <code>CharacterData</code></h3>
<pre class=idl>interface <dfn>CharacterData</dfn> : <span>Node</span> {
  [TreatNullAs=EmptyString] attribute DOMString <span title=dom-CharacterData-data>data</span>;
  readonly attribute unsigned long <span title=dom-CharacterData-length>length</span>;
  DOMString <span title=dom-CharacterData-substringData>substringData</span>(unsigned long <var title>offset</var>, unsigned long <var title>count</var>);
  void <span title=dom-CharacterData-appendData>appendData</span>(DOMString <var title>data</var>);
  void <span title=dom-CharacterData-insertData>insertData</span>(unsigned long <var title>offset</var>, DOMString <var title>data</var>);
  void <span title=dom-CharacterData-deleteData>deleteData</span>(unsigned long <var title>offset</var>, unsigned long <var title>count</var>);
  void <span title=dom-CharacterData-replaceData>replaceData</span>(unsigned long <var title>offset</var>, unsigned long <var title>count</var>, DOMString <var title>data</var>);
};</pre>

<p>The <dfn title=dom-CharacterData-data><code>data</code></dfn> attribute must return the data of the node, and on setting, must change the node's data to the new value.

<p>The <dfn title=dom-CharacterData-length><code>length</code></dfn> attribute must return the number of UTF-16 code units represented by the node's data.

<p>The
<dfn title=dom-CharacterData-substringData><code>substringData(<var title>offset</var>, <var title>count</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>If <var title>offset</var> is greater than the
 <span>context object</span>'s <code title=dom-CharacterData-length>length</code>,
 throw an <code title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code>
 exception and terminate these steps.

 <li><p>If <span title><var title>offset</var>+<var title>count</var></span> is
 greater than the <span>context object</span>'s <code
 title=dom-CharacterData-length>length</code>, return a <code
 data-anolis-spec=webidl>DOMString</code> whose value is the UTF-16 code units
 from the <var title>offset</var>th UTF-16 code unit to the end of <var
 title>data</var>.

 <li><p>Return a <code data-anolis-spec=webidl>DOMString</code> whose value is
 the UTF-16 code units from the <var title>offset</var>th UTF-16 code unit to
 the <span title><var title>offset</var>+<var title>count</var></span>th UTF-16
 code unit in <var title>data</var>.
</ol>

<p>The <dfn title=dom-CharacterData-appendData><code>appendData(<var title>data</var>)</code></dfn> method must append <var title>data</var> to the <span>context object</span>'s data.

<p>The <dfn title=dom-CharacterData-insertData><code>insertData(<var title>offset</var>, <var title>data</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var title>offset</var> is greater than the <span>context object</span>'s
 <code title=dom-CharacterData-length>length</code>, throw an
 <code title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code> exception
 and terminate these steps.

 <li><p>Insert <var title>data</var> into the <span>context object</span>'s data
 after <var title>offset</var> UTF-16 code units.
</ol>

<p>The <dfn title=dom-CharacterData-deleteData><code>deleteData(<var title>offset</var>, <var title>count</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var title>offset</var> is greater than the <span>context object</span>'s
 <code title=dom-CharacterData-length>length</code>, throw an
 <code title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code> exception
 and terminate these steps.

 <li><p>If <var title>offset</var>+<var title>count</var> is greater than the
 <span>context object</span>'s
 <code title=dom-CharacterData-length>length</code> let <var title>count</var> be
 <code title=dom-CharacterData-length>length</code>-<var title>offset</var>.

 <li><p>Starting from <var title>offset</var> UTF-16 code units remove
 <var title>count</var> UTF-16 code units from the <span>context object</span>'s
 data.
</ol>

<p>The
<dfn title=dom-CharacterData-replaceData><code>replaceData(<var title>offset</var>, <var title>count</var>, <var title>data</var>)</code></dfn>
method must act as if the
<code title=dom-CharacterData-deleteData>deleteData()</code> method is invoked
with <var title>offset</var> and <var title>count</var> as arguments followed by
the <code title=dom-CharacterData-insertData>insertData()</code> method with
<var title>offset</var> and <var title>data</var> as arguments and re-throw any
exceptions these methods might have thrown.


<h3>Interface <code>Text</code></h3>
<pre class=idl>interface <dfn>Text</dfn> : <span>CharacterData</span> {
  <span>Text</span> <span title=dom-Text-splitText>splitText</span>(unsigned long <var title>offset</var>);<!--
  readonly attribute boolean isElementContentWhitespace;-->
  readonly attribute DOMString <span title=dom-Text-wholeText>wholeText</span>;
  <span>Text</span> <span title=dom-Text-replaceWholeText>replaceWholeText</span>(DOMString <var title>data</var>);
};</pre>

<p>The
<dfn title=dom-Text-splitText><code>splitText(<var title>offset</var>)</code></dfn>
method must run the following steps:

<ol>
  <li>If <var title>offset</var> is greater than the <span>context object</span>'s
  <code title=dom-CharacterData-length>length</code>, throw an
  <code title=dom-DOMException-INDEX_SIZE_ERR>INDEX_SIZE_ERR</code> exception
  and terminate these steps.

  <li>Let <var title>length</var> be the <span>context object</span>'s
  <span title><code title=dom-CharacterData-length>length</code> &minus;
  <var title>offset</var></span>.

  <li>Call the <span>context object</span>'s
  <code title=dom-CharacterData-substringData>substringData</code> method with
  <var title>offset</var> and <var title>length</var> as its arguments.
  If this threw an exception, terminate these steps. Otherwise, let
  <var title>new data</var> be the value returned.

  <li>Call the <span>context object</span>'s
  <code title=dom-CharacterData-deleteData>deleteData</code> method with
  <var title>offset</var> and <var title>length</var> as its arguments.
  If this threw an exception, terminate these steps.

  <li>Let <var title>new node</var> be a new <code>Text</code> object, with the
  same <code title=dom-Node-ownerDocument>ownerDocument</code> as the
  <span>context object</span>. Set <var title>new node</var>'s
  <code title=dom-CharacterData-data>data</code> to <var title>new data</var>.

  <li>Let <var title>parent</var> be the <span>context object</span>'s
  <span title=concept-tree-parent>parent</span>. If <var title>parent</var>
  is null, return <var title>new node</var> and terminate these steps.

  <li>Call <var title>parent</var>'s
  <code title=dom-Node-insertBefore>insertBefore</code> method with
  <var title>new node</var> and the <span>context object</span>'s first
  <span title=concept-tree-next-sibling>next sibling</code> as its argument.

  <li>Return <var title>new node</var>.
</ol>

<p>The <dfn>contiguous <code>Text</code> nodes</dfn> of a node are the node
itself, the previous sibling <code>Text</code> node (if any) and its
<span>contiguous <code>Text</code> nodes</span>, and the next sibling
<code>Text</code> node (if any) and its
<span>contiguous <code>Text</code> nodes</span>, avoiding any
duplicates.

<p>The <dfn title=dom-Text-wholeText><code>wholeText</code></dfn>
attribute must return a concatenation of the
<code title=dom-CharacterData-data>data</code> of the
<span>contiguous <code>Text</code> nodes</span> of the
<span>context object</span>, in <span>tree order</span>.

<p>The
<dfn title=dom-Text-replaceWholeText><code>replaceWholeText(<var title>data</var>)</code></dfn>
method must run these steps:

<ol>
 <li><p>Remove the <span>contiguous <code>Text</code> nodes</span> of the
 <span>context object</span>.
 <li><p>If <var title>data</var> is not the empty string, insert a new
 <code>Text</code> node whose
 <code title=dom-CharacterData-data>data</code> is <var title>data</var> at the
 place of the removed nodes, return the new <code>Text</code> node, and
 then terminate these steps.
 <li><p>Return null.
</ol>

<p class=XXX>Can we remove replaceWholeText() in favor of making wholeText no longer readonly? Do we even need this wholeText business?

<!-- isElementContentWhitespace: Mozilla returns true if the node contains only
space, tab, newline -->


<h3>Interface <code>Comment</code></h3>
<pre class=idl>interface <dfn>Comment</dfn> : <span>CharacterData</span> {
};</pre>



<h2>Collections</h2>
<p>A <dfn title=concept-collection>collection</dfn> is an object that
represents a lists of DOM nodes. A
<span title=concept-collection>collection</span> can be either
<dfn title=concept-collection-live>live</dfn> or
<dfn title=concept-collection-static>static</dfn>. Unless otherwise stated,
a <span title=concept-collection>collection</span> must be
<span title=concept-collection-live>live</span>.

<p>If a <span title=concept-collection>collection</span> is <span
title=concept-collection-live>live</span>, then the attributes and methods
on that object must operate on the actual underlying data, not a snapshot of
the data.

<p>When a <span title=concept-collection>collection</span> is created, a
filter and a root are associated with it.

<p>The <span title=concept-collection>collection</span> then
<dfn title="represented by the collection">represents</dfn> a view of the
subtree rooted at the <span title=concept-collection>collection's</span>
root, containing only nodes that match the given filter. The view is linear.
In the absence of specific requirements to the contrary, the nodes within
the <span title=concept-collection>collection</span> must be sorted in
<span>tree order</span>.

<p>An attribute that returns a
<span title=concept-collection-live>live</span>
<span title=concept-collection>collection</span> must return the same object
every time it is retrieved.


<h3>Interface <code>NodeList</code></h3>
<p>A <code>NodeList</code> object is a kind of
<span title=concept-collection>collection</span>.

<pre class=idl>interface <dfn>NodeList</dfn> {
  getter <span>Node</span> <span title=dom-NodeList-item>item</span>(unsigned long index);
  readonly attribute unsigned long <span title=dom-NodeList-length>length</span>;
};</pre>

<dl class=domintro>
 <dt><var title>collection</var> . <code title=dom-NodeList-length>length</code>
 <dd>
  <p>Returns the number of elements in the collection.

 <dt><var title>element</var> = <var title>collection</var> . <code title=dom-NodeList-item>item</code>(<var title>index</var>)
 <dt><var title>element</var> = <var title>collection</var>[<var title>index</var>]
 <dd>
  <p>Returns the item with index <var title>index</var> from the collection. The items are sorted in <span>tree order</span>.
  <p>Returns null if <var title>index</var> is out of range.
</dl>

<div class=impl>

<p>The object's <span data-anolis-spec=webidl>supported property indices</span>
are the numbers in the range zero to one less than the number of nodes
<span>represented by the collection</span>. If there are no such elements, then
there are no <span data-anolis-spec=webidl>supported property indices</span>.

<p>The <dfn title=dom-NodeList-length><code>length</code></dfn> attribute must
return the number of nodes <span>represented by the collection</span>.

<p>The <dfn title=dom-NodeList-item><code>item(<var
title>index</var>)</code></dfn> method must return the <var title>index</var>th
node in the <span title=concept-collection>collection</span>. If there is no
<var title>index</var>th node in the <span
title=concept-collection>collection</span>, then the method must return null.

</div>


<h3>Interface <code>HTMLCollection</code></h3>
<p>The <code>HTMLCollection</code> interface represents a generic <span
title=concept-collection>collection</span> of elements.

<p class=note>This interface is called <code>HTMLCollection</code> for
historical reasons. The various getters on this interface return <code
data-anolis-spec=webidl>object</code> for interfaces that inherit from
it, which return other objects for historical reasons.

<pre class=idl>interface <dfn>HTMLCollection</dfn> {
  readonly attribute unsigned long <span title=dom-HTMLCollection-length>length</span>;
  getter <span>Element</span> <span title=dom-HTMLCollection-item>item</span>(unsigned long index);
  getter object <span title=dom-HTMLCollection-namedItem>namedItem</span>(DOMString name); // only returns <code>Element</code>
};</pre>

<dl class=domintro>
 <dt><var title>collection</var> . <code title=dom-HTMLCollection-length>length</code>
 <dd>
  <p>Returns the number of elements in the collection.

 <dt><var title>element</var> = <var title>collection</var> . <code title=dom-HTMLCollection-item>item</code>(<var title>index</var>)
 <dt><var title>element</var> = <var title>collection</var>[<var title>index</var>]
 <dd>
  <p>Returns the item with index <var title>index</var> from the collection. The items are sorted in <span>tree order</span>.
  <p>Returns null if <var title>index</var> is out of range.

 <dt><var title>element</var> = <var title>collection</var> . <code title=dom-HTMLCollection-namedItem>namedItem</code>(<var title>name</var>)
 <dt><var title>element</var> = <var title>collection</var>[<var title>name</var>]
 <dd>
  <p>Returns the first item with <span title="concept-id">ID</span> or name <var title>name</var>
  from the collection.
  <p>Returns null if no element with that <span title="concept-id">ID</span> or name could be found.
  <p>Only <code title>a</code>, <code title>applet</code>,
  <code title>area</code>, <code title>embed</code>,
  <code title>form</code>, <code title>frame</code>,
  <code title>frameset</code>, <code title>iframe</code>,
  <code title>img</code>, and <code title>object</code> elements in the
  <span>HTML namespace</span> can have a name for the purpose of this
  method; their name is given by the value of their
  <code title>name</code> attribute.
</dl>

<div class=impl>

<p>The object's <span data-anolis-spec=webidl>supported property indices</span>
are the numbers in the range zero to one less than the number of nodes
<span>represented by the collection</span>. If there are no such elements, then
there are no <span data-anolis-spec=webidl>supported property indices</span>.

<p>The <dfn title=dom-HTMLCollection-length><code>length</code></dfn> attribute
must return the number of nodes <span>represented by the collection</span>.

<p>The <dfn title=dom-HTMLCollection-item><code>item(<var
title>index</var>)</code></dfn> method must return the <var
title>index</var>th node in the collection. If there is no <var
title>index</var>th node in the collection, then the method must
return null.

<p>The <span data-anolis-spec=webidl>supported property names</span> consist
of the values of the <code title>name</code> attributes of each <code
title>a</code>, <code title>applet</code>, <code title>area</code>, <code
title>embed</code>, <code title>form</code>, <code title>frame</code>, <code
title>frameset</code>, <code title>iframe</code>, <code title>img</code>, and
<code title>object</code> element in the <span>HTML namespace</span>,
<span>represented by the collection</span> with a <code title>name</code>
attribute, plus the list of <span title=concept-id>IDs</span> that the elements
<span>represented by the collection</span> have.

<p>The
<dfn title=dom-HTMLCollection-namedItem><code>namedItem(<var title>key</var>)</code></dfn>
method must return the first node in the
<span title=concept-collection>collection</span> that falls into one of the
following categories:

<ul>
 <li>It is an <code title>a</code>, <code title>applet</code>, <code
 title>area</code>, <code title>embed</code>, <code title>form</code>, <code
 title>frame</code>, <code title>frameset</code>, <code title>iframe</code>,
 <code title>img</code>, or <code title>object</code> element, in the <span>HTML
 namespace</span>, with a <code title>name</code> attribute equal to <var
 title>key</var>, or,

 <li>It is an element with an <span title=concept-id>ID</span>
 equal to <var title>key</var>.
</ul>

<p>If no such elements are found, then the method must return
null.

</div>


<!-- AttrExodus
<h3>Interface <code>NamedNodeMap</code></h3>
<p>Since <code title=dom-Node-attributes>attributes</code> is the
only remaining API using this interface and the tentative plan is to change
<code>Attr</code> we also plan to remove this interface and replace it with
a lightweight <code>AttrMap</code> or some such &mdash;
<a href=http://lists.w3.org/Archives/Public/public-webapps/2010JulSep/0797.html>http://lists.w3.org/Archives/Public/public-webapps/2010JulSep/0797.html</a>

<p>A <code>NamedNodeMap</code> object is a kind of <span
title=concept-collection>collection</span>, whose primary purpose is to expose
<code>Node</code>s by name.

<pre class=idl>interface <dfn>NamedNodeMap</dfn> {
  <span>Node</span> <span title=dom-NamedNodeMap-getNamedItem>getNamedItem</span>(DOMString name);
  <span>Node</span> <span title=dom-NamedNodeMap-setNamedItem>setNamedItem</span>(<span>Node</span> arg);
  <span>Node</span> <span title=dom-NamedNodeMap-removeNamedItem>removeNamedItem</span>(DOMString name);
  <span>Node</span> <span title=dom-NamedNodeMap-item>item</span>(unsigned long index);
  readonly attribute unsigned long <span title=dom-NamedNodeMap-length>length</span>;
  <span>Node</span> <span title=dom-NamedNodeMap-getNamedItemNS>getNamedItemNS</span>(DOMString namespace, DOMString localName);
  <span>Node</span> <span title=dom-NamedNodeMap-setNamedItemNS>setNamedItemNS</span>(<span>Node</span> arg);
  <span>Node</span> <span title=dom-NamedNodeMap-removeNamedItemNS>removeNamedItemNS</span>(DOMString namespace, DOMString localName);
};</pre>

<p><dfn title=dom-NamedNodeMap-getNamedItem>getNamedItem</dfn>

<p><dfn title=dom-NamedNodeMap-setNamedItem>setNamedItem</dfn>

<p><dfn title=dom-NamedNodeMap-removeNamedItem>removeNamedItem</dfn>

<p><dfn title=dom-NamedNodeMap-item>item</dfn>

<p>The <dfn title=dom-NamedNodeMap-length><code>length</code></dfn> attribute must return the number of nodes <span>represented by the collection</span>.

<p><dfn title=dom-NamedNodeMap-getNamedItemNS>getNamedItemNS</dfn>

<p><dfn title=dom-NamedNodeMap-setNamedItemNS>setNamedItemNS</dfn>

<p><dfn title=dom-NamedNodeMap-removeNamedItemNS>removeNamedItemNS</dfn>
-->


<h2>Lists</h2>

<h3>Interface <code>DOMStringList</code></h3>

<p class="XXX">Only HTMLPropertiesCollection.names, DataTranser.types, Clipboard.types, and Document.styleSheetSets seem to use this API. Should they use something like DOMString[] instead if Web IDL introduces that?

<pre class=idl>interface <dfn>DOMStringList</dfn> {
  readonly attribute unsigned long <span title=dom-DOMStringList-length>length</span>;
  getter DOMString <span title=dom-DOMStringList-item>item</span>(unsigned long <var title>index</var>);
  boolean <span title=dom-DOMStringList-contains>contains</span>(DOMString <var title>string</var>);
};</pre>

<p>The <code>DOMStringList</code> interface represents an interface to an
ordered list of strings.

<dl class="domintro">
 <dt><var title>stringlist</var> . <code title="dom-DOMStringList-length">length</code>
 <dd><p>Returns the number of tokens in the string.

 <dt><var title>string</var> = <var title>stringlist</var> . <code title="dom-DOMStringList-item">item</code>(<var title>index</var>)
 <dt><var title>stringlist</var>[<var title>index</var>]
 <dd>
  <p>Returns the string with index <var title>index</var>.
  <p>Returns null if <var title>index</var> is out of range.

 <dt><var title>hasstring</var> = <var title>stringlist</var> . <code title="dom-DOMStringList-contains">contains</code>(<var title>string</var>)
 <dd><p>Returns true if the <var title>string</var> is present; false
 otherwise.
</dl>

<div class=impl>

<p>The <dfn title="dom-DOMStringList-length"><code>length</code></dfn>
attribute must return the number of strings in the list.

<p>The object's
<span data-anolis-spec=webidl>supported property indices</span> are the
numbers in the range zero to
<code title=dom-DOMStringList-length>length</code>&minus;1, unless the
<code title=dom-DOMStringList-length>length</code> is zero, in which case
there are no
<span data-anolis-spec=webidl>supported property indices</span>.

<p>The
<dfn title=dom-DOMStringList-item><code>item(<var title>index</var>)</code></dfn>
method must return the <var title>index</var>th string in the list. If
<var title>index</var> is equal to or greater than the number of strings, then the
method must return null.

<p>The
<dfn title=dom-DOMStringList-contains><code>contains(<var title>string</var>)</code></dfn>
method must return true if the list of strings contains <var title>string</var>,
or false otherwise.

</div>


<h3>Interface <code>DOMTokenList</code></h3>
<p>The <code>DOMTokenList</code> interface represents an interface
to an underlying string that consists of a <span>set of
space-separated tokens</span>.

<p class="note"><code>DOMTokenList</code> objects are always
<span>case-sensitive</span>, even when the underlying string might
ordinarily be treated in a case-insensitive manner.

<pre class="idl">interface <dfn>DOMTokenList</dfn> {
  readonly attribute unsigned long <span title="dom-DOMTokenList-length">length</span>;
  getter DOMString <span title="dom-DOMTokenList-item">item</span>(unsigned long index);
  boolean <span title="dom-DOMTokenList-contains">contains</span>(DOMString token);
  void <span title="dom-DOMTokenList-add">add</span>(DOMString token);
  void <span title="dom-DOMTokenList-remove">remove</span>(DOMString token);
  boolean <span title="dom-DOMTokenList-toggle">toggle</span>(DOMString token);
  <span title="dom-DOMTokenList-toString">stringifier</span> DOMString ();
};</pre>

<dl class="domintro">
 <dt><var title>tokenlist</var> . <code title="dom-DOMTokenList-length">length</code>
 <dd>
  <p>Returns the number of tokens in the string.

 <dt><var title>element</var> = <var title>tokenlist</var> . <code title="dom-DOMTokenList-item">item</code>(<var title>index</var>)
 <dt><var title>tokenlist</var>[<var title>index</var>]
 <dd>
  <p>Returns the token with index <var title>index</var>. The tokens are returned in the order they are found in the underlying string.
  <p>Returns null if <var title>index</var> is out of range.

 <dt><var title>hastoken</var> = <var title>tokenlist</var> . <code title="dom-DOMTokenList-contains">contains</code>(<var title>token</var>)
 <dd>
  <p>Returns true if the <var title>token</var> is present; false otherwise.
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var title>token</var> is empty.
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var title>token</var> contains any spaces.

 <dt><var title>tokenlist</var> . <code title="dom-DOMTokenList-add">add</code>(<var title>token</var>)
 <dd>
  <p>Adds <var title>token</var>, unless it is already present.
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var title>token</var> is empty.
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var title>token</var> contains any spaces.

 <dt><var title>tokenlist</var> . <code title="dom-DOMTokenList-remove">remove</code>(<var title>token</var>)
 <dd>
  <p>Removes <var title>token</var> if it is present.
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var title>token</var> is empty.
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var title>token</var> contains any spaces.

 <dt><var title>hastoken</var> = <var title>tokenlist</var> . <code title="dom-DOMTokenList-toggle">toggle</code>(<var title>token</var>)
 <dd>
  <p>Adds <var title>token</var> if it is not present, or removes
  it if it is. Returns true if <var title>token</var> is now
  present (it was added); returns false if it is not (it was
  removed).
  <p>Throws a <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception if <var title>token</var> is empty.
  <p>Throws an <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code> exception if <var title>token</var> contains any spaces.
</dl>

<div class="impl">

<p>The <dfn title="dom-DOMTokenList-length"><code>length</code></dfn>
attribute must return the number of tokens that result from <span
title="split a string on spaces">splitting the underlying string on
spaces</span>. This is the <var
title="dom-DOMTokenList-length">length</var>.

<p>The object's <span data-anolis-spec=webidl>supported property indices</span>
are the numbers in the range zero to
<span title><var title="dom-DOMTokenList-length">length</var>&minus;1</span>,
unless the <var title="dom-DOMTokenList-length">length</var> is zero, in which
case there are no
<span data-anolis-spec=webidl>supported property indices</span>.

<p>The
<dfn title="dom-DOMTokenList-item"><code>item(<var title>index</var>)</code></dfn>
method must
<span title="split a string on spaces">split the underlying string on spaces</span>,
preserving the order of the tokens as found in the underlying string, and then
return the <var title>index</var>th item in this list. If <var title>index</var>
is equal to or greater than the number of tokens, then the method must return null.

<p class="example">For example, if the string is "<code title>a b a c</code>"
then there are four tokens: the token with index 0 is "<code title>a</code>",
the token with index 1 is "<code title>b</code>", the token with index 2 is
"<code title>a</code>", and the token with index 3 is "<code title>c</code>".

<p>The
<dfn title="dom-DOMTokenList-contains"><code>contains(<var title>token</var>)</code></dfn>
method must run the following algorithm:

<ol>
 <li>If the <var title>token</var> argument is the empty string, then throw a
 <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and
 terminate these steps.

 <li>If the <var title>token</var> argument contains any
 <span title="space character">space characters</span>, then throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li>Otherwise,
 <span title="split a string on spaces">split the underlying string on spaces</span>
 to get the list of tokens in the object's underlying string.

 <li>If the token indicated by <var title>token</var> is a
 <span>case-sensitive</span> match for one of the tokens in the object's
 underlying string then return true and terminate these steps.

 <li>Otherwise, return false.
</ol>

<p>The
<dfn title="dom-DOMTokenList-add"><code>add(<var title>token</var>)</code></dfn>
method must run the following algorithm:

<ol>
 <li>If the <var title>token</var> argument is the empty string, then throw a
 <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and
 terminate these steps.

 <li>If the <var title>token</var> argument contains any
 <span title="space character">space characters</span>, then throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li>Otherwise,
 <span title="split a string on spaces">split the underlying string on spaces</span>
 to get the list of tokens in the object's underlying string.

 <li>If the given <var title>token</var> is a <span>case-sensitive</span> match
 for one of the tokens in the <code>DOMTokenList</code> object's underlying
 string then terminate these steps.

 <li>Otherwise, if the <code>DOMTokenList</code> object's underlying string is
 not the empty string and the last character of that string is not a
 <span>space character</span>, then append a U+0020 SPACE character to the end
 of that string.

 <li>Append the value of <var title>token</var> to the end of the
 <code>DOMTokenList</code> object's underlying string.
</ol>

<p>The
<dfn title="dom-DOMTokenList-remove"><code>remove(<var title>token</var>)</code></dfn>
method must run the following algorithm:

<ol>
 <li>If the <var title>token</var> argument is the empty string, then throw a
 <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and
 terminate these steps.

 <li>If the <var title>token</var> argument contains any
 <span title="space character">space characters</span>, then throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li>Otherwise,
 <span title="remove a token from a string">remove the given <var title>token</var> from the underlying string</span>.
</ol>

<p>The
<dfn title="dom-DOMTokenList-toggle"><code>toggle(<var title>token</var>)</code></dfn>
method must run the following algorithm:

<ol>
 <li>If the <var title>token</var> argument is the empty string, then throw a
 <code title=dom-DOMException-SYNTAX_ERR>SYNTAX_ERR</code> exception and
 terminate these steps.

 <li>If the <var title>token</var> argument contains any
 <span title="space character">space characters</span>, then throw an
 <code title=dom-DOMException-INVALID_CHARACTER_ERR>INVALID_CHARACTER_ERR</code>
 exception and terminate these steps.

 <li>Otherwise,
 <span title="split a string on spaces">split the underlying string on spaces</span>
 to get the list of tokens in the object's underlying string.

 <li>If the given <var title>token</var> is a <span>case-sensitive</span> match
 for one of the tokens in the <code>DOMTokenList</code> object's underlying
 string then
 <span title="remove a token from a string">remove the given <var title>token</var> from the underlying string</span>,
 return false and terminate these steps.

 <li>Otherwise, if the <code>DOMTokenList</code> object's underlying string is
 not the empty string and the last character of that string is not a
 <span>space character</span>, then append a U+0020 SPACE character to the end
 of that string.

 <li>Append the value of <var title>token</var> to the end of the
 <code>DOMTokenList</code> object's underlying string.

 <li>Return true.
</ol>

<p>Objects implementing the <code>DOMTokenList</code> interface must
<dfn title="dom-DOMTokenList-toString">stringify</dfn> to the object's
underlying string representation.

</div>


<h3>Interface <code>DOMSettableTokenList</code></h3>

<p>The <code>DOMSettableTokenList</code> interface is the same as the
<code>DOMTokenList</code> interface, except that it allows the
underlying string to be directly changed.

<pre class="idl">interface <dfn>DOMSettableTokenList</dfn> : <span>DOMTokenList</span> {
            attribute DOMString <span title="dom-DOMSettableTokenList-value">value</span>;
};</pre>

<dl class="domintro">
 <dt><var title>tokenlist</var> . <code title="dom-DOMSettableTokenList-value">value</code>
 <dd>
  <p>Returns the underlying string.
  <p>Can be set, to change the underlying string.
</dl>

<div class="impl">

<p>An object implementing the <code>DOMSettableTokenList</code>
interface must act as defined for the <code>DOMTokenList</code>
interface, except for the <code
title="dom-DOMSettableTokenList-value">value</code> attribute defined
here.

<p>The <dfn
title="dom-DOMSettableTokenList-value"><code>value</code></dfn>
attribute must return the underlying string and, on setting must replace the underlying string with the new value.

</div>



<h2>DOM features</h2>
<p class=warning>Authors are strongly discouraged from using
<span title=concept-DOMfeature>DOM features</span>, as they are notoriously
unreliable and imprecise. Authors are encouraged to rely on explicit feature
testing or graceful degradation.

<p>A <dfn title=concept-DOMfeature>DOM feature</dfn> is a unique,
<span>ASCII case-insensitive</span> string that represents a certain feature of
the user agent.

<p>A <dfn title=concept-DOMfeatureversion>DOM feature version</dfn> is a (<var title>feature</var>,&nbsp;<var title>version</var>) tuple, where <var title>feature</var> is <span title=concept-DOMfeature>DOM feature</span>
and <var title>version</var> is a <span>case-sensitive</span> string
representing a version number.
<!--of the form "<var title>major</var>.<var title>minor</var>".-->

<p>Specifications may define which <span title=concept-DOMfeature>DOM
features</span> a user agent is to <dfn
title=concept-support-DOMfeature>support</dfn>, as well as an associated list of
one or more <span>case-sensitive</span> strings representing version numbers, and under which circumstances, when necessary for compatibility (i.e. because of historical use). Specifications must not introduce new <span title=concept-DOMfeature>DOM
features</span> or new versions for existing features.

<div class=impl>

<p>A user agent must <dfn title=concept-support-DOMfeatureversion>support</dfn>
a <span title=concept-DOMfeatureversion>DOM feature version</span> (<var
title>feature</var>,&nbsp;<var title>version</var>) if it <span
title=concept-support-DOMfeature>supports</span> a <span
title=concept-DOMfeature>DOM feature</span> that is a <span>ASCII
case-insensitive</span> match for <var title>feature</var> and <var
title>version</var> is in the associated list of versions.

<p>A user agent must <span
title=concept-support-DOMfeatureversion>support</span> the (<var
title>feature</var>,&nbsp;"") tuple if it <span
title=concept-support-DOMfeature>supports</span> a <span
title=concept-DOMfeature>DOM feature</span> that is a <span>ASCII
case-insensitive</span> match for <var title>feature</var>.

<p>For historical reasons, user agents must <span
title=concept-support-DOMfeatureversion>support</span> the
"XML" <span title=concept-DOMfeature>DOM feature</span> with the versions "1.0"
and "2.0" associated with it, and the "Core" <span title=concept-DOMfeature>DOM
feature</span> with the version "2.0" associated with it.

<!-- Chrome supports Core/1.0; Opera supports x/undefined -->

</div>



<h2>Historical</h2>

<!-- XXX we should probably just nuke this section in due course. No need to keep old dreams alive. -->

<p>As explained in <a href="#goals">goals</a> this specification attempts to
update various DOM specifications. Along the way a number of changes has
been made of which this section is a rough summary.

<p>The features defined by this specification mostly originated elsewhere
and have been moved here as this was deemed a more appropriate location. As
such this specification includes features defined by former DOM Events and
DOM Core specifications, features once defined by HTML, and features defined
by the Element Traversal specification.</p>

<h3>DOM Events</h3>

<p>This specification only replaces the core event model and not any of the
events for specific contexts (e.g. user interface events).

<p>It makes the following changes:</p>

<ul class=brief>
 <li>No more restrictions on <code title=dom-Event-type>Event.type</code>.
 <li>No need to invoke <code title=dom-Event-initEvent>initEvent()</code> to
 initialize an event.</li>
 <li><code title=dom-Event-preventDefault>preventDefault()</code> only
 changes what <code title=dom-Event-defaultPrevented>defaultPrevented</code>
 and <code title=dom-EventTarget-dispatchEvent>dispatchEvent()</code> return
 if the event is cancelable.
 <li>Removes <dfn><code>EventException</code></dfn>.
 <li>Fire is no longer synonymous with dispatch, but includes initializing
 an event.</li>
 <li>The propagation and canceled flags are unset when invoking
 <code title=dom-Event-initEvent>initEvent()</code> rather than after
 dispatch.
</ul>


<h3>DOM Core</h3>

<p><dfn><code>DOMString</code></dfn> and
<dfn><code>DOMTimeStamp</code></dfn> originally defined in DOM Level 3 Core
are now defined in Web IDL.

<p><code>Node</code> now inherits from <code>EventTarget</code>.</p>

<p>The remainder of interfaces and interface members listed in this section
were once part of DOM Core. Implementations conforming to this specification
will not support them.

<p>Interfaces:
<ul class=brief>
 <li><dfn><code>CDATASection</code></dfn>
 <li><dfn><code>DOMConfiguration</code></dfn>
 <li><dfn><code>DOMError</code></dfn>
 <li><dfn><code>DOMErrorHandler</code></dfn>
 <li><dfn><code>DOMImplementationList</code></dfn>
 <li><dfn><code>DOMImplementationSource</code></dfn>
 <li><dfn><code>DOMLocator</code></dfn>
 <li><dfn><code>DOMObject</code></dfn>
 <li><dfn><code>DOMUserData</code></dfn>
 <li><dfn><code>Entity</code></dfn>
 <li><dfn><code>EntityReference</code></dfn>
 <li><dfn><code>NamedNodeMap</code></dfn> <!--AttrExodus-->
 <li><dfn><code>NameList</code></dfn>
 <li><dfn><code>Notation</code></dfn>
 <li><dfn><code>TypeInfo</code></dfn>
 <li><dfn><code>UserDataHandler</code></dfn>
</ul>

<p>Interface members:
<dl>
 <dt><code>Node</code>
 <dd>
  <!--AttrExodus-->
  <p><dfn title=dom-Node-hasAttributes><code>hasAttributes()</code></dfn>
  <p><dfn title=dom-Node-attributes><code>attributes</code></dfn>

  <!--NodeExodus-->
  <p><dfn title=dom-Node-namespaceURI><code>namespaceURI</code></dfn>
  <p><dfn title=dom-Node-prefix><code>prefix</code></dfn>
  <p><dfn title=dom-Node-localName><code>localName</code></dfn>


  <p><dfn title=dom-Node-normalize><code>normalize()</code></dfn>
  <p><dfn title=dom-Node-isSupported><code>isSupported</code></dfn>
  <p><dfn title=dom-Node-getFeature><code>getFeature()</code></dfn>
  <p><dfn title=dom-Node-getUserData><code>getUserData()</code></dfn>
  <p><dfn title=dom-Node-setUserData><code>setUserData()</code></dfn>

 <dt><code>Document</code>
 <dd>
  <p><dfn title=dom-Document-createCDATASection><code>createCDATASection()</code></dfn>
  <p><dfn title=dom-Document-createAttribute><code>createAttribute()</code></dfn>
  <p><dfn title=dom-Document-createAttributeNS><code>createAttributeNS()</code></dfn>
  <p><dfn title=dom-Document-inputEncoding><code>inputEncoding</code></dfn>
  <p><dfn title=dom-Document-xmlEncoding><code>xmlEncoding</code></dfn>
  <p><dfn title=dom-Document-xmlStandalone><code>xmlStandalone</code></dfn>
  <p><dfn title=dom-Document-xmlVersion><code>xmlVersion</code></dfn>
  <p><dfn title=dom-Document-strictErrorChecking><code>strictErrorChecking</code></dfn>
  <p><dfn title=dom-Document-domConfig><code>domConfig</code></dfn>
  <p><dfn title=dom-Document-normalizeDocument><code>normalizeDocument()</code></dfn>
  <p><dfn title=dom-Document-renameNode><code>renameNode()</code></dfn>

 <dt><code>DOMImplementation</code>
 <dd>
  <p><dfn title=dom-DOMImplementation-getFeature><code>getFeature()</code></dfn>

 <dt><code>Attr</code>
 <dd>
  <p>No longer inherits from <code>Node</code> and therefore completely
  changed.
  <!--AttrExodus
  <p><dfn title=dom-Attr-schemaTypeInfo><code>schemaTypeInfo</code></dfn>
  <p><dfn title=dom-Attr-isId><code>isId</code></dfn>
  -->

 <dt><code>Element</code>
 <dd>
  <p><dfn title=dom-Element-getAttributeNode><code>getAttributeNode()</code></dfn>
  <p><dfn title=dom-Element-getAttributeNodeNS><code>getAttributeNodeNS()</code></dfn>
  <p><dfn title=dom-Element-setAttributeNode><code>setAttributeNode()</code></dfn>
  <p><dfn title=dom-Element-removeAttributeNode><code>removeAttributeNode()</code></dfn>
  <p><dfn title=dom-Element-schemaTypeInfo><code>schemaTypeInfo</code></dfn>
  <p><dfn title=dom-Element-setIdAttribute><code>setIdAttribute()</code></dfn>
  <p><dfn title=dom-Element-setIdAttributeNS><code>setIdAttributeNS()</code></dfn>
  <p><dfn title=dom-Element-setIdAttributeNode><code>setIdAttributeNode()</code></dfn>

 <dt><code>DocumentType</code>
 <dd>
  <p><dfn title=dom-DocumentType-entities><code>entities</code></dfn>
  <p><dfn title=dom-DocumentType-notations><code>notations</code></dfn>
  <p><dfn title=dom-DocumentType-internalSubset><code>internalSubset</code></dfn>

 <dt><code>Text</code>
 <dd>
  <p><dfn title=dom-Text-isElementContentWhitespace><code>isElementContentWhitespace</code></dfn>
</dl>


<h3>HTML</h3>

<p>A number of DOM methods behave in a special way based on the
<span>HTML namespace</span> or <span>HTML document</span> variables. This
specification makes that an intrinsic part of the DOM.



<h2 class=no-num>References</h2>
<h3 class=no-num>Normative references</h3>
<div id=anolis-references-normative></div>

<h3 class=no-num>Informative references</h3>
<div id=anolis-references-informative></div>



<h2 class=no-num>Acknowledgements</h2>

<p>Thanks to

Adrian Bateman,
Dethe Elza,
Glenn Maynard,
Jacob Rossi,
Jonas Sicking,
Henri Sivonen,
Ojan Vafai,
Olli Pettay, and
Shiki Okasaka

for their useful comments.

<p>Special thanks to Geoffrey Sneddon and Simon Pieters for editing the initial
version of this specification and their useful comments.

<p>Special thanks also to Ian Hickson for first specifying some parts of
this specification in HTML and his useful comments.
<span data-anolis-ref class=informative>HTML</span>

<p>Finally, while this specification has been written from scratch, special
thanks should also be extended to the editors of the various specifications
that previously defined the features in this specification. In particular:
<ul>
<li>Arnaud Le Hors
<li>Björn Höhrmann
<li>Doug Schepers
<li>Gavin Nicol
<li>Jonathan Robie
<li>Lauren Wood
<li>Mike Champion
<li>Philippe Le Hégaret
<li>Robin Berjon
<li>Steve Byrne
<li>Tom Pixley
</ul>
